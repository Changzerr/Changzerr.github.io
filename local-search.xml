<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="红黑树学习"><a href="#红黑树学习" class="headerlink" title="红黑树学习"></a>红黑树学习</h2><p>代码地址：<a href="https://github.com/Changzerr/javaPractice/blob/main/src/dataStructure/RBTree.java">https://github.com/Changzerr/javaPractice/blob/main/src/dataStructure/RBTree.java</a></p><h3 id="为什么使用红黑树"><a href="#为什么使用红黑树" class="headerlink" title="为什么使用红黑树"></a>为什么使用红黑树</h3><p>红黑树（RBT）：插入&#x2F;删除很多时候不会破坏“红黑”特性 无需频繁调整树的形态。即便需要调整，一般都可以在常数级时间内完成</p><p>平衡二叉树：适用于以查为主、很少插入&#x2F;删除场景</p><p>红黑树：适用于频繁插入、删除的场景，实用性更强</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p> 左子树 &lt; 当前节点 &lt; 右子树</p></blockquote><p>1）每个结点或是红色，或是黑色的</p><p>2）根结点是黑色的</p><p>3）叶结点（外部结点、NULL结点、失败结点）均是黑色的</p><p>4）不存在两个相邻的红结点（即红结点的父节点和孩子结点均为黑色）</p><p>5）对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RBTreeNode</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> T value;<span class="hljs-comment">//node value</span><br>    <span class="hljs-keyword">private</span> RBTreeNode&lt;T&gt; left;<span class="hljs-comment">//left child pointer</span><br>    <span class="hljs-keyword">private</span> RBTreeNode&lt;T&gt; right;<span class="hljs-comment">//right child pointer</span><br>    <span class="hljs-keyword">private</span> RBTreeNode&lt;T&gt; parent;<span class="hljs-comment">//parent pointer</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> red;<span class="hljs-comment">//color is red or not red</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://images.changzer.cn/image-20221102192032891.png" alt="image-20221102192032891"></p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul><li><p>先查找，确定插入位置（原理同二叉排序树），插入新结点</p></li><li><p>新结点是根——染为黑色</p></li><li><p>新结点非根——染为红色</p><ul><li><p>若插入新结点后依然满足红黑树定义，则插入结束</p></li><li><p>若插入新结点后不满足红黑树定义，需要调整，使其重新 满足红黑树定义</p><ul><li>黑叔：旋转+染色 <ul><li>LL：右单旋，父换爷+染色；</li><li>RR：左单旋，父换爷+染色；</li><li>LR：左、右双旋，儿换爷+染色；</li><li>RL：右、左双旋，儿换爷+染色</li></ul></li><li>红叔：染色+变新  <ul><li>叔父爷染色+爷变新结点</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * add node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">addNode</span><span class="hljs-params">(RBTreeNode&lt;T&gt; node)</span>&#123;<br>    <span class="hljs-comment">//init node</span><br>    node.setLeft(<span class="hljs-literal">null</span>);<br>    node.setRight(<span class="hljs-literal">null</span>);<br>    node.setRed(<span class="hljs-literal">true</span>);<br>    setParent(node,<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">if</span>(root.getLeft()==<span class="hljs-literal">null</span>)&#123;  <span class="hljs-comment">//RBTree not have node</span><br>        <span class="hljs-comment">//node become root</span><br>        root.setLeft(node);<br>        <span class="hljs-comment">//root node is black</span><br>        node.setRed(<span class="hljs-literal">false</span>);<br>        size.incrementAndGet();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        RBTreeNode&lt;T&gt; x = findParentNode(node); <span class="hljs-comment">//find the parent of insert position</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> x.getValue().compareTo(node.getValue());<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.overrideMode &amp;&amp; cmp==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> x.getValue();<br>            x.setValue(node.getValue());<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//value exists,ignore this node</span><br>            <span class="hljs-keyword">return</span> x.getValue();<br>        &#125;<br><br>        <span class="hljs-comment">//x become node&#x27;s parent</span><br>        setParent(node,x);<br><br>        <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            x.setLeft(node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x.setRight(node);<br>        &#125;<br><br>        <span class="hljs-comment">//Keep RBTree&#x27;s identity.</span><br>        fixInsert(node);<br>        size.incrementAndGet();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * find the parent node to hold node x,if parent value equals x.value return parent.</span><br><span class="hljs-comment"> * be used to find insert position</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> RBTreeNode&lt;T&gt; <span class="hljs-title function_">findParentNode</span><span class="hljs-params">(RBTreeNode&lt;T&gt; x)</span>&#123;<br>    <span class="hljs-comment">//get root</span><br>    RBTreeNode&lt;T&gt; dataRoot = getRoot();<br>    RBTreeNode&lt;T&gt; child = dataRoot;<br><br>    <span class="hljs-keyword">while</span>(child!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//compare value</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> child.getValue().compareTo(x.getValue());<br>        <span class="hljs-comment">//the same value, return it</span><br>        <span class="hljs-keyword">if</span>(cmp==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> child;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cmp&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//node&#x27;value &gt; x&#x27;value, turn left</span><br>            dataRoot = child;<br>            child = child.getLeft();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//node&#x27;value &lt; x&#x27;value, turn right</span><br>            dataRoot = child;<br>            child = child.getRight();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//return x&#x27;s parent</span><br>    <span class="hljs-keyword">return</span> dataRoot;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * red black tree insert fix.</span><br><span class="hljs-comment"> * when Red is connected to red, we need fix RBTress。</span><br><span class="hljs-comment"> * if insert node&#x27;s uncle is null(black),</span><br><span class="hljs-comment"> *          case 1: LL type, rotate right, change the color of parent and ancestor</span><br><span class="hljs-comment"> *          case 2: RR type, rotate left, change the color of parent and ancestor</span><br><span class="hljs-comment"> *          case 3: LR type, first rotate left and then rotate right, change the color of current and ancestor</span><br><span class="hljs-comment"> *          case 4: RL type, first rotate Right and then rotate left, change the color of current and ancestor</span><br><span class="hljs-comment"> * else insert node&#x27;s uncle is red:</span><br><span class="hljs-comment"> *          change the color of parent and ancestor，and look on the ancestor as new insert node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixInsert</span><span class="hljs-params">(RBTreeNode&lt;T&gt; x)</span>&#123;<br>    <span class="hljs-comment">//get parent node</span><br>    RBTreeNode&lt;T&gt; parent = x.getParent();<br><br>    <span class="hljs-comment">//if both node and parent are red</span><br>    <span class="hljs-keyword">while</span>(parent!=<span class="hljs-literal">null</span> &amp;&amp; parent.isRed())&#123;<br>        <span class="hljs-comment">//get uncle</span><br>        RBTreeNode&lt;T&gt; uncle = getUncle(x);<br>        <span class="hljs-keyword">if</span>(uncle==<span class="hljs-literal">null</span> || !uncle.isRed())&#123; <span class="hljs-comment">//need to rotate</span><br>            <span class="hljs-comment">//get ancestor</span><br>            RBTreeNode&lt;T&gt; ancestor = parent.getParent();<br>            <span class="hljs-comment">//ancestor is not null due to before before add,tree color is balance</span><br>            <span class="hljs-keyword">if</span>(parent == ancestor.getLeft())&#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">isRight</span> <span class="hljs-operator">=</span> x == parent.getRight();<br>                <span class="hljs-keyword">if</span>(isRight)&#123;<br>                    <span class="hljs-comment">//LR type, need rotateLeft and rotate Right</span><br>                    rotateLeft(parent);<br>                &#125;<br>                rotateRight(ancestor);<br><br>                <span class="hljs-keyword">if</span>(isRight)&#123;<br>                    <span class="hljs-comment">//LR type, need change current and ancestor&#x27;s color</span><br>                    x.setRed(<span class="hljs-literal">false</span>);<br>                    parent=<span class="hljs-literal">null</span>;<span class="hljs-comment">//end loop</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//LL type, need change parent and ancestor&#x27;s color</span><br>                    parent.setRed(<span class="hljs-literal">false</span>);<br>                &#125;<br>                ancestor.setRed(<span class="hljs-literal">true</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeft</span> <span class="hljs-operator">=</span> x == parent.getLeft();<br>                <span class="hljs-keyword">if</span>(isLeft)&#123;<br>                    <span class="hljs-comment">//RL type, need rotate Right and rotate Left</span><br>                    rotateRight(parent);<br>                &#125;<br>                rotateLeft(ancestor);<br><br>                <span class="hljs-keyword">if</span>(isLeft)&#123;<br>                    <span class="hljs-comment">//RL type, need change current and ancestor&#x27;s color</span><br>                    x.setRed(<span class="hljs-literal">false</span>);<br>                    parent=<span class="hljs-literal">null</span>;<span class="hljs-comment">//end loop</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//RR type, need change parent and ancestor&#x27;s color</span><br>                    parent.setRed(<span class="hljs-literal">false</span>);<br>                &#125;<br>                ancestor.setRed(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//uncle is red</span><br>            parent.setRed(<span class="hljs-literal">false</span>);<br>            uncle.setRed(<span class="hljs-literal">false</span>);<br>            parent.getParent().setRed(<span class="hljs-literal">true</span>);<br>            x=parent.getParent();<br>            <span class="hljs-comment">//ancestor become new insert node</span><br>            parent = x.getParent();<br>        &#125;<br>    &#125;<br>    getRoot().makeBlack();<br>    getRoot().setParent(<span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * get uncle node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> RBTreeNode&lt;T&gt; <span class="hljs-title function_">getUncle</span><span class="hljs-params">(RBTreeNode&lt;T&gt; node)</span>&#123;<br>    <span class="hljs-comment">//get parent</span><br>    RBTreeNode&lt;T&gt; parent = node.getParent();<br>    <span class="hljs-comment">//get 祖先</span><br>    RBTreeNode&lt;T&gt; ancestor = parent.getParent();<br>    <span class="hljs-keyword">if</span>(ancestor==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(parent == ancestor.getLeft())&#123;<br>        <span class="hljs-comment">//ancestor&#x27;s left is parent, the right is uncle</span><br>        <span class="hljs-keyword">return</span> ancestor.getRight();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//else left is uncle</span><br>        <span class="hljs-keyword">return</span> ancestor.getLeft();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rotate left</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(RBTreeNode&lt;T&gt; node)</span>&#123;<br>    <span class="hljs-comment">//获取右孩子</span><br>    RBTreeNode&lt;T&gt; right = node.getRight();<br>    <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IllegalStateException(<span class="hljs-string">&quot;right node is null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//获取父结点</span><br>    RBTreeNode&lt;T&gt; parent = node.getParent();<br>    <span class="hljs-comment">//当前节点的右孩子设为right的左孩子</span><br>    node.setRight(right.getLeft());<br>    <span class="hljs-comment">//right的左孩子的父结点设为当前</span><br>    setParent(right.getLeft(),node);<br><br>    <span class="hljs-comment">//right的左孩子设为当前节点</span><br>    right.setLeft(node);<br>    <span class="hljs-comment">//当前节点的父结点设为right</span><br>    setParent(node,right);<br><br>    <span class="hljs-keyword">if</span>(parent==<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//当前节点是根节点</span><br>        <span class="hljs-comment">//right  raise to root node</span><br>        root.setLeft(right);<br>        setParent(right,<span class="hljs-literal">null</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(parent.getLeft()==node)&#123;<br>            parent.setLeft(right);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent.setRight(right);<br>        &#125;<br>        <span class="hljs-comment">//right.setParent(parent);</span><br>        setParent(right,parent);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * rotate right</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(RBTreeNode&lt;T&gt; node)</span>&#123;<br>    <span class="hljs-comment">//获取左孩子</span><br>    RBTreeNode&lt;T&gt; left = node.getLeft();<br>    <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.IllegalStateException(<span class="hljs-string">&quot;left node is null&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//获取父结点</span><br>    RBTreeNode&lt;T&gt; parent = node.getParent();<br>    <span class="hljs-comment">//当前节点左孩子设为left的右孩子</span><br>    node.setLeft(left.getRight());<br>    <span class="hljs-comment">//left的右孩子的父结点设为当前节点</span><br>    setParent(left.getRight(),node);<br><br>    <span class="hljs-comment">//left的右孩子设为当前节点</span><br>    left.setRight(node);<br>    <span class="hljs-comment">//设置当前节点的父结点为left</span><br>    setParent(node,left);<br><br>    <span class="hljs-keyword">if</span>(parent==<span class="hljs-literal">null</span>)&#123;   <span class="hljs-comment">//说明是根节点</span><br>        <span class="hljs-comment">//将left设为根节点</span><br>        root.setLeft(left);<br>        setParent(left,<span class="hljs-literal">null</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//将父结点的孩子指向left</span><br>        <span class="hljs-keyword">if</span>(parent.getLeft()==node)&#123;<br>            parent.setLeft(left);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent.setRight(left);<br>        &#125;<br>        <span class="hljs-comment">//将left的父结点设为parent</span><br>        setParent(left,parent);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统——（2）进程与线程</title>
    <link href="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-进程的概念、组成、特征"><a href="#1-进程的概念、组成、特征" class="headerlink" title="1 进程的概念、组成、特征"></a>1 进程的概念、组成、特征</h2><h3 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 进程的概念</h3><p>程序：是静态得到，就是存放在磁盘里的可执行文件，就是一系列的指令集合</p><p>进程：是动态的，是程序（同一个程序执行会对应多个进程）的一次执行过程</p><h3 id="1-2-进程的组成——PCB"><a href="#1-2-进程的组成——PCB" class="headerlink" title="1.2 进程的组成——PCB"></a>1.2 进程的组成——PCB</h3><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”——PID</p><p><img src="http://images.changzer.cn/image-20221010143548514.png" alt="image-20221010143548514"></p><p>操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</p><p><img src="http://images.changzer.cn/image-20221010143613205.png" alt="image-20221010143613205"></p><blockquote><p>PCB信息：</p><p>进程标识符</p><p>处理机状态</p><p>进程调度信息</p><p>进程控制信息</p><p>PCB的组织方式：</p><p>线性方式</p><p>链接方式</p><p>索引方式</p></blockquote><p><img src="http://images.changzer.cn/image-20221010143708399.png" alt="image-20221010143708399"></p><blockquote><p>PCB是给操作系统用的；程序段、数据段是给进程自已用的</p><p>与进程自身的运行逻辑有关</p></blockquote><p><img src="http://images.changzer.cn/image-20221010143746801.png" alt="image-20221010143746801"></p><p>一个<strong>进程实体</strong>（进程映像）由PCB、程序段、数据段组成。进程是动态的，进程实体（进程映像）是静态的</p><p>进程实体反应了进程在某一时刻的状态</p><p><img src="http://images.changzer.cn/Snipaste_2022-10-10_14-39-11.png" alt="Snipaste_2022-10-10_14-39-11"></p><p>注意：PCB是进程存在的唯一标志</p><h3 id="1-3-进程的特征"><a href="#1-3-进程的特征" class="headerlink" title="1.3 进程的特征"></a>1.3 进程的特征</h3><p><img src="http://images.changzer.cn/image-20221010144038138.png" alt="image-20221010144038138"></p><p><img src="http://images.changzer.cn/image-20221010144047345.png" alt="image-20221010144047345"></p><blockquote><p>操作系统的目标：</p><p>程序顺序执行：一个较大的程序通常由若干个程序段组成</p><p>程序在执行时，必须按照某种先后顺序逐个执行，仅当前一操作执行完后，才能执行后继操作</p><p>前趋图：有向无循环图，用于描述进程之间执行的先后顺序；结点表示进程或程序段，有向边表示前驱关系</p><p>程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行</p></blockquote><h2 id="2-进程的状态与转换、进程的组织"><a href="#2-进程的状态与转换、进程的组织" class="headerlink" title="2 进程的状态与转换、进程的组织"></a>2 进程的状态与转换、进程的组织</h2><h3 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 进程的状态</h3><h4 id="2-1-1-创建态、就绪态"><a href="#2-1-1-创建态、就绪态" class="headerlink" title="2.1.1 创建态、就绪态"></a>2.1.1 创建态、就绪态</h4><p>进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程<strong>分配资源、初始化PCB</strong></p><p>当进程创建完成后，便进入“就绪态”，处于就绪态的进程<strong>已经具备运行条件，但由于没有空闲CPU</strong>，就暂时不能运行</p><h4 id="2-1-2-运行态"><a href="#2-1-2-运行态" class="headerlink" title="2.1.2 运行态"></a>2.1.2 运行态</h4><p>当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。如果一个进程此时<strong>在CPU上运行</strong>，那么这个进程处于“<strong>运行态</strong>”CPU会执行该进程对应的程序（执行指令序列）</p><h4 id="2-1-3-阻塞态"><a href="#2-1-3-阻塞态" class="headerlink" title="2.1.3 阻塞态"></a>2.1.3 阻塞态</h4><p>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）</p><p><strong>在这个事件发生之前</strong>，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”</p><p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行</p><h4 id="2-1-4-终止态"><a href="#2-1-4-终止态" class="headerlink" title="2.1.4 终止态"></a>2.1.4 终止态</h4><p>一个进程可以<strong>执行exit系统调用</strong>，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB</p><p>当终止进程的工作完成之后，这个<strong>进程就彻底消失了</strong></p><h3 id="2-2-进程状态的转换"><a href="#2-2-进程状态的转换" class="headerlink" title="2.2 进程状态的转换"></a>2.2 进程状态的转换</h3><p><img src="http://images.changzer.cn/image-20221010144621449.png" alt="image-20221010144621449"></p><p><img src="http://images.changzer.cn/image-20221010144646991.png" alt="image-20221010144646991"></p><p><img src="http://images.changzer.cn/image-20221010144715770.png" alt="image-20221010144715770"></p><h3 id="2-3-进程的组织"><a href="#2-3-进程的组织" class="headerlink" title="2.3 进程的组织"></a>2.3 进程的组织</h3><h4 id="2-3-1-链式方式"><a href="#2-3-1-链式方式" class="headerlink" title="2.3.1 链式方式"></a>2.3.1 链式方式</h4><p><img src="http://images.changzer.cn/image-20221010144748658.png" alt="image-20221010144748658"></p><p><img src="http://images.changzer.cn/image-20221010144827584.png" alt="image-20221010144827584"></p><h4 id="2-3-2-索引方式"><a href="#2-3-2-索引方式" class="headerlink" title="2.3.2 索引方式"></a>2.3.2 索引方式</h4><p><img src="http://images.changzer.cn/image-20221010144858905.png" alt="image-20221010144858905"></p><p><img src="http://images.changzer.cn/image-20221010144914239.png" alt="image-20221010144914239"></p><p><img src="http://images.changzer.cn/image-20221010144935329.png" alt="image-20221010144935329"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3 进程控制"></a>3 进程控制</h2><h3 id="3-1-什么是进程控制？（实现进程状态转换）"><a href="#3-1-什么是进程控制？（实现进程状态转换）" class="headerlink" title="3.1 什么是进程控制？（实现进程状态转换）"></a>3.1 什么是进程控制？（实现进程状态转换）</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</p><h3 id="3-2-如何实现进程控制？（用“原语”实现）"><a href="#3-2-如何实现进程控制？（用“原语”实现）" class="headerlink" title="3.2 如何实现进程控制？（用“原语”实现）"></a>3.2 如何实现进程控制？（用“原语”实现）</h3><p>原语是一种特殊的程序，它的执行具有<strong>原子性</strong>（可以用“关中断指令”和”开中断指令“这两个特权指令实现原子性）。也就是说，这段程序的运行必须是一气呵成，不可中断</p><p>如果不“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</p><p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序</p><p>CPU执行了<strong>关中断</strong>指令之后，就<strong>不再例行检查中断信号</strong>，直到执行<strong>开中断</strong>指令之后才会<strong>恢复检查</strong>。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</p><h3 id="3-3-进程控制相关的原语"><a href="#3-3-进程控制相关的原语" class="headerlink" title="3.3 进程控制相关的原语"></a>3.3 进程控制相关的原语</h3><p><img src="http://images.changzer.cn/image-20221010145330417.png" alt="image-20221010145330417"></p><p><img src="http://images.changzer.cn/image-20221010145413228.png" alt="image-20221010145413228"></p><p><img src="http://images.changzer.cn/image-20221010145448296.png" alt="image-20221010145448296"></p><p><img src="http://images.changzer.cn/image-20221010145550936.png" alt="image-20221010145550936"></p><blockquote><p>CPU中会设置很多“寄存器”，用来存放程序运行过程中所需的某些数据</p><p>​PSW：程序状态寄存器</p><p>​PC：程序计数器，存放下一条指令的地址</p><p>​IR：指令寄存器，存放当前正在执行的指令</p><p>​通用寄存器：其他一些必要信息</p></blockquote><p><img src="http://images.changzer.cn/image-20221010145728062.png" alt="image-20221010145728062"></p><h2 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4 进程通信"></a>4 进程通信</h2><h3 id="4-1-什么是进程通信？"><a href="#4-1-什么是进程通信？" class="headerlink" title="4.1 什么是进程通信？"></a>4.1 什么是进程通信？</h3><p>是指两个进程之间产生<strong>数据交互</strong></p><h3 id="4-2-为什么进程通信需要操作系统支持"><a href="#4-2-为什么进程通信需要操作系统支持" class="headerlink" title="4.2 为什么进程通信需要操作系统支持?"></a>4.2 为什么进程通信需要操作系统支持?</h3><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong></p><p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong></p><h3 id="4-3-共享存储"><a href="#4-3-共享存储" class="headerlink" title="4,3 共享存储"></a>4,3 共享存储</h3><p><img src="http://images.changzer.cn/image-20221010150302739.png" alt="image-20221010150302739"></p><p><img src="http://images.changzer.cn/image-20221010150331896.png" alt="image-20221010150331896"></p><blockquote><p>为避免出错，各个进程对共享空间的访问应该是互斥的。各个进程可使用操作系统内核提供的同步互斥工具（例如P、V操作）</p></blockquote><p><img src="http://images.changzer.cn/image-20221010150436136.png" alt="image-20221010150436136"></p><h3 id="4-4-消息传递"><a href="#4-4-消息传递" class="headerlink" title="4.4 消息传递"></a>4.4 消息传递</h3><p> 进程间的数据交换以<strong>格式化的消息</strong>为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个<strong>原语</strong>进行数据交换</p><p><img src="http://images.changzer.cn/image-20221010150633375.png" alt="image-20221010150633375"></p><h4 id="4-4-1-直接通信方式（点名道姓的通信方式）"><a href="#4-4-1-直接通信方式（点名道姓的通信方式）" class="headerlink" title="4.4.1 直接通信方式（点名道姓的通信方式）"></a>4.4.1 直接通信方式（点名道姓的通信方式）</h4><p><img src="http://images.changzer.cn/image-20221010150721842.png" alt="image-20221010150721842"></p><h4 id="4-4-2-间接通信方式（以“信箱”作为中间实体进行消息传递）"><a href="#4-4-2-间接通信方式（以“信箱”作为中间实体进行消息传递）" class="headerlink" title="4.4.2 间接通信方式（以“信箱”作为中间实体进行消息传递）"></a>4.4.2 间接通信方式（以“信箱”作为中间实体进行消息传递）</h4><p><img src="http://images.changzer.cn/image-20221010150802608.png" alt="image-20221010150802608"></p><h3 id="4-5-管道通信"><a href="#4-5-管道通信" class="headerlink" title="4.5 管道通信"></a>4.5 管道通信</h3><p><img src="http://images.changzer.cn/image-2022101015090120.png" alt="image-2022101015090120"></p><p>“管道”是一种特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个<strong>大小固定</strong>的内存缓冲区</p><p><img src="http://images.changzer.cn/image-20221010151122203.png" alt="image-20221010151122203"></p><p><img src="http://images.changzer.cn/image-20221010151227214.png" alt="image-20221010151227214"></p><h2 id="5-线程的概念"><a href="#5-线程的概念" class="headerlink" title="5 线程的概念"></a>5 线程的概念</h2><h3 id="5-1-什么是线程，为什么要引入线程？"><a href="#5-1-什么是线程，为什么要引入线程？" class="headerlink" title="5.1 什么是线程，为什么要引入线程？"></a>5.1 什么是线程，为什么要引入线程？</h3><p>还没有引入进程之前，系统中各个程序只能串行执行</p><p>有的进程可能需要“同时”做很多事，二传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度</p><p>传统的进程是程序执行流的最小单位</p><p>引入线程后，线程成为了程序需执行流的最小单位</p><p><code>可以把线程理解为“轻量级进程”</code></p><p>线程是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p><p>引入线程之后，不仅是进程之间可以并发，<strong>进程内的各线程之间也可以并发</strong>，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务；进程只是作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</p><h3 id="5-2-引入线程机制后，有什么变化？"><a href="#5-2-引入线程机制后，有什么变化？" class="headerlink" title="5.2 引入线程机制后，有什么变化？"></a>5.2 引入线程机制后，有什么变化？</h3><p><img src="http://images.changzer.cn/image-20221010151751838.png" alt="image-20221010151751838"></p><h3 id="5-3-线程的属性"><a href="#5-3-线程的属性" class="headerlink" title="5.3 线程的属性"></a>5.3 线程的属性</h3><p><img src="http://images.changzer.cn/image-20221010151901647.png" alt="image-20221010151901647"></p><h2 id="6-线程的实现方式和多线程模型"><a href="#6-线程的实现方式和多线程模型" class="headerlink" title="6 线程的实现方式和多线程模型"></a>6 线程的实现方式和多线程模型</h2><h3 id="6-1-线程的实现方式"><a href="#6-1-线程的实现方式" class="headerlink" title="6.1 线程的实现方式"></a>6.1 线程的实现方式</h3><h4 id="6-1-1-用户级线程"><a href="#6-1-1-用户级线程" class="headerlink" title="6.1.1 用户级线程"></a>6.1.1 用户级线程</h4><p>历史背景：早期的操作系统只支持进程，不支持线程。当时的“线程”是由线程库实现的。</p><p><img src="http://images.changzer.cn/image-20221010152031415.png" alt="image-20221010152031415"></p><blockquote><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能</p></blockquote><p>1.线程的管理工作是由应用程序通过线程库来完成，所有的线程管理工作都由应用程序负责</p><p>2.线程切换不需要操作系统干涉，线程切换可以在用户态下即可完成</p><p>3.操作系统不能意识到用户级线程的存在，“用户级线程”就是“从用户视角看能看到的线程”</p><p>4.优缺点</p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的开销小，效率高</p><p>缺点：当一个<strong>用户级线程被阻塞</strong>后，整个<strong>进程都会被阻塞</strong>，并发度不高。<strong>多个线程不可在多核处理机上并行运行</strong></p><h4 id="6-1-2-内核级线程（由操作系统支持的线程）"><a href="#6-1-2-内核级线程（由操作系统支持的线程）" class="headerlink" title="6.1.2 内核级线程（由操作系统支持的线程）"></a>6.1.2 内核级线程（由操作系统支持的线程）</h4><p><img src="http://images.changzer.cn/image-20221010152635080.png" alt="image-20221010152635080"></p><p>1.<strong>内核级线程的管理工作</strong>由<strong>操作系统</strong>内核完成。<br>2.线程调度、切换等工作都由内核负责，因此<strong>内核级线程</strong>的切换必然需要在<strong>核心态</strong>下才能完成。<br>3.操作系统会为每个内核级线程建立相应的TCB (Thread Control Block，线程控制块），通过TCB对线程进行管理。<strong>“内核级线程”</strong>就是<strong>“从操作系统内核视角看能看到的线程”</strong><br>4.优缺点<br>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h3 id="6-2多线程模型"><a href="#6-2多线程模型" class="headerlink" title="6.2多线程模型"></a>6.2多线程模型</h3><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p><p><img src="http://images.changzer.cn/image-20221012173448890.png" alt="image-20221012173448890"></p><p><img src="http://images.changzer.cn/image-20221012173532916.png" alt="image-20221012173532916"></p><p><img src="http://images.changzer.cn/image-20221012173543906.png" alt="image-20221012173543906"></p><p><img src="http://images.changzer.cn/image-20221012173554227.png" alt="image-20221012173554227"></p><p>内核级进程中可以运行任意一个有映射关心的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。</p><p><img src="http://images.changzer.cn/image-20221012173636419.png" alt="image-20221012173636419"></p><h2 id="7-线程的状态与转换"><a href="#7-线程的状态与转换" class="headerlink" title="7 线程的状态与转换"></a>7 线程的状态与转换</h2><p><img src="http://images.changzer.cn/image-20221012173700437.png" alt="image-20221012173700437"></p><h3 id="7-1-线程的组织与控制"><a href="#7-1-线程的组织与控制" class="headerlink" title="7.1 线程的组织与控制"></a>7.1 线程的组织与控制</h3><p><img src="http://images.changzer.cn/image-20221012173730326.png" alt="image-20221012173730326"></p><h2 id="8-调度的概念、层次"><a href="#8-调度的概念、层次" class="headerlink" title="8 调度的概念、层次"></a>8 调度的概念、层次</h2><h3 id="8-1-高级调度"><a href="#8-1-高级调度" class="headerlink" title="8.1 高级调度"></a>8.1 高级调度</h3><p><img src="http://images.changzer.cn/image-20221012174659287.png" alt="image-20221012174659287"></p><p><img src="http://images.changzer.cn/image-20221012174725534.png" alt="image-20221012174725534"></p><h3 id="8-2-中级调度"><a href="#8-2-中级调度" class="headerlink" title="8.2 中级调度"></a>8.2 中级调度</h3><p><strong>内存不够</strong>时，可将某些进程的数据<strong>调出外存</strong>。等内存空闲或者进程需要运行时再重新调入内存</p><p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></p><p>中级调度（内存调度）—— 按照某种策略决定将哪个处于挂起状态的进程重新调入内存</p><h3 id="8-3-低级调度"><a href="#8-3-低级调度" class="headerlink" title="8.3 低级调度"></a>8.3 低级调度</h3><p>低级调度（进程调度&#x2F;处理机调度）——按照某种策略从就绪队列中选取一个进程，将处理机分配给它</p><p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度</p><p>进程调度的频率很高，一般几十毫秒一次</p><h3 id="8-4-进程的挂起态与七状态模型"><a href="#8-4-进程的挂起态与七状态模型" class="headerlink" title="8.4 进程的挂起态与七状态模型"></a>8.4 进程的挂起态与七状态模型</h3><p>暂时调到外存等待的进程状态为挂起状态</p><p>挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态</p><p>五状态模型-&gt;七状态模型</p><p><img src="http://images.changzer.cn/image-20221012175127048.png" alt="image-20221012175127048"></p><p><img src="http://images.changzer.cn/image-20221012175144177.png" alt="image-20221012175144177"></p><p><img src="http://images.changzer.cn/image-20221012175149878.png" alt="image-20221012175149878"></p><p><img src="http://images.changzer.cn/image-20221012175238915.png" alt="image-20221012175238915"></p><h2 id="9-进程调度的时机、切换与过程调度方式"><a href="#9-进程调度的时机、切换与过程调度方式" class="headerlink" title="9 进程调度的时机、切换与过程调度方式"></a>9 进程调度的时机、切换与过程调度方式</h2><h3 id="9-1-进程调度的时机"><a href="#9-1-进程调度的时机" class="headerlink" title="9.1 进程调度的时机"></a>9.1 进程调度的时机</h3><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机</p><p><img src="http://images.changzer.cn/image-20221012175443017.png" alt="image-20221012175443017"></p><p><img src="http://images.changzer.cn/image-20221012175502080.png" alt="image-20221012175502080"></p><p>临界资源：<strong>一个时间段</strong>只允许<strong>一个进程</strong>使用的资源。各进程需要<strong>互斥</strong>地访问临界资源</p><p>临界区：访问临界资源的那段代码</p><p><strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p><img src="http://images.changzer.cn/image-20221012175612313.png" alt="image-20221012175612313"></p><h3 id="9-2-进程调度的方式"><a href="#9-2-进程调度的方式" class="headerlink" title="9.2 进程调度的方式"></a>9.2 进程调度的方式</h3><ol><li><p><strong>非剥夺调度方式</strong>，又称<strong>非抢占方式</strong>。即，只允许进程<strong>主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</p><p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p></li><li><p><strong>剥夺调度方式</strong>，又称<strong>抢占方式</strong>。当一个进程正在进程处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则<strong>立即暂停正在执行的进程</strong>，将处理机<strong>分配给更重要紧迫的那个进程</strong></p><p>可以优先处理更紧急的进程，也可实现让各进程时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p></li></ol><h3 id="9-3-进程的切换与过程"><a href="#9-3-进程的切换与过程" class="headerlink" title="9.3 进程的切换与过程"></a>9.3 进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别：</p><p><code>狭义的进程调度</code>指的是<strong>从就绪队列中选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p><p><code>广义的进程调度</code>包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li><p>对<strong>原来</strong>运行进程各种<strong>数据的保存</strong></p></li><li><p>对<strong>新的进程</strong>各种数据的<strong>恢复</strong>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p></li></ol><p>注意：<strong>进程切换是有代价</strong>的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少</p><p><img src="http://images.changzer.cn/image-20221012175900557.png" alt="image-20221012175900557"></p><h2 id="10-调度器和闲逛进程"><a href="#10-调度器和闲逛进程" class="headerlink" title="10 调度器和闲逛进程"></a>10 调度器和闲逛进程</h2><h3 id="10-1-调度器-x2F-调度程序"><a href="#10-1-调度器-x2F-调度程序" class="headerlink" title="10.1 调度器&#x2F;调度程序"></a>10.1 调度器&#x2F;调度程序</h3><p><img src="http://images.changzer.cn/image-20221012180405086.png" alt="image-20221012180405086"></p><p><img src="http://images.changzer.cn/image-20221012180433959.png" alt="image-20221012180433959"></p><h3 id="10-2-闲逛进程"><a href="#10-2-闲逛进程" class="headerlink" title="10.2 闲逛进程"></a>10.2 闲逛进程</h3><p>调度程序永远的备胎，<strong>没有其他就绪进程时，运行闲逛进程</strong></p><p>特性：</p><p>1）优先级最低</p><p>2）可以是0地址指令，站一个完整的指令周期（<strong>指令周期末尾例行检查中断</strong>）</p><p>3）能耗低</p><h2 id="11-调度算法的评价指标"><a href="#11-调度算法的评价指标" class="headerlink" title="11 调度算法的评价指标"></a>11 调度算法的评价指标</h2><h3 id="11-1-CPU利用率"><a href="#11-1-CPU利用率" class="headerlink" title="11.1 CPU利用率"></a>11.1 CPU利用率</h3><p>由于早期的CPU造价及其昂贵，因此人们会希望让CPU尽可能多迪工作</p><p>CPU利用率：指CPU“忙碌”的时间占总时间的比例</p><p><img src="http://images.changzer.cn/image-20221012181358834.png" alt="image-20221012181358834"></p><p>通常会考察<strong>多道程序并发执行</strong>的情况，可以用“甘特图”来辅助计算</p><h3 id="11-2-系统吞吐量"><a href="#11-2-系统吞吐量" class="headerlink" title="11.2 系统吞吐量"></a>11.2 系统吞吐量</h3><p>单位时间内完成作业的数量</p><p><img src="http://images.changzer.cn/image-20221012181424511.png" alt="image-20221012181424511"></p><h3 id="11-3-周转时间"><a href="#11-3-周转时间" class="headerlink" title="11.3 周转时间"></a>11.3 周转时间</h3><p>是指从<strong>作业被提交给系统开始</strong>，<strong>到作业完成为止</strong>的这段时间间隔</p><p>它包括四个部分：</p><ol><li><p>作业在外存<strong>后备队列</strong>上等待作业调度（高级调度）的时间</p></li><li><p>进程在<strong>就绪队列</strong>上等待进程调度（低级调度）的时间</p></li><li><p>进程在<strong>CPU上</strong>执行的时间</p></li><li><p>进程<strong>等待I&#x2F;O</strong>操作完成的时间</p></li></ol><p>后三项在一个作业的整个处理过程中，可能发生多次</p><p><img src="http://images.changzer.cn/Snipaste_2022-10-12_18-15-49.png" alt="Snipaste_2022-10-12_18-15-49"></p><p>有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的</p><p><img src="http://images.changzer.cn/image-20221012181727007.png" alt="image-20221012181727007"></p><p>对于周转时间相同的两个作业，实际运行时间长的作业相同时间内被服务的时间更多，带权周转时间更小，用户满意度更带权周转时间与周转时间都是越小越好</p><p><img src="http://images.changzer.cn/image-20221012181706132.png" alt="image-20221012181706132"></p><h3 id="11-4-等待时间"><a href="#11-4-等待时间" class="headerlink" title="11.4 等待时间"></a>11.4 等待时间</h3><p>指进程&#x2F;作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低</p><p>作业在后备队里等待被服务（调度）。作业调入内存后，建立对应的进程。这个进程会被CPU服务</p><p>会被I&#x2F;O设备服务，当然也会有等待被服务的时候</p><p>对于进程来说，等待时间就是指<strong>进程建立后等待被服务的时间之和</strong>，在<strong>等待I&#x2F;O完成的期间其实进程也是在被服务</strong>的，所以不计入等待时间</p><p>对于作业来说，不仅要考虑<strong>建立进程后的等待时间</strong>，还要加上<strong>作业在外存后备队列中等待的时间</strong></p><p><img src="http://images.changzer.cn/image-20221012181940115.png" alt="image-20221012181940115"></p><h3 id="11-4-响应时间"><a href="#11-4-响应时间" class="headerlink" title="11.4 响应时间"></a>11.4 响应时间</h3><p>指从用户<strong>提交请求到首次产生响应</strong>所用的时间</p><p><img src="http://images.changzer.cn/image-20221012182031958.png" alt="image-20221012182031958"></p><h2 id="12-调度算法"><a href="#12-调度算法" class="headerlink" title="12 调度算法"></a>12 调度算法</h2><h3 id="12-1-先来先服务（FCFS）"><a href="#12-1-先来先服务（FCFS）" class="headerlink" title="12.1 先来先服务（FCFS）"></a>12.1 先来先服务（FCFS）</h3><p><img src="http://images.changzer.cn/image-20221012182329968.png" alt="image-20221012182329968"></p><p><img src="http://images.changzer.cn/image-20221012182439478.png" alt="image-20221012182439478"></p><p>优点：公平、算法实现简单</p><p>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法<strong>对长作业有利，对短作业不利</strong></p><p><strong>不会导致饥饿</strong></p><h3 id="12-2-短作业优先（SJF）"><a href="#12-2-短作业优先（SJF）" class="headerlink" title="12.2 短作业优先（SJF）"></a>12.2 短作业优先（SJF）</h3><p><img src="http://images.changzer.cn/image-20221012182619877.png" alt="image-20221012182619877"></p><p>使用短进程优先调度算法</p><p><strong>每次调度当前<code>已经到达</code>且<code>运行时间最短</code>的作业&#x2F;进程</strong></p><p><img src="http://images.changzer.cn/image-20221012182805675.png" alt="image-20221012182805675"></p><p><img src="http://images.changzer.cn/image-20221012182752900.png" alt="image-20221012182752900"></p><p>对比FCFS算法的结果，显然SPF算法的平均等待&#x2F;周转&#x2F;带权周转时间都要更低</p><p>​<code>“最短剩余时间优先算法”</code></p><p>每当<strong>有进程加入就绪队列</strong>改变时就<strong>需要调度</strong>，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p><p><img src="http://images.changzer.cn/image-20221012183124526.png" alt="image-20221012183124526"></p><p>注意几个小细节：</p><p>1.如果题目中未特别说明，所提到的<strong>默认是非抢占式</strong></p><p>2.在<strong>所有进程同时可运行时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少</p><p>或者在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少</p><p><img src="C:\Users\neiko\AppData\Roaming\Typora\typora-user-images\image-20221012183531724.png" alt="image-20221012183531724"></p><p><img src="http://images.changzer.cn/image-20221012183543204.png" alt="image-20221012183543204"></p><p><img src="http://images.changzer.cn/image-20221012185822142.png" alt="image-20221012185822142"></p><p><img src="http://images.changzer.cn/image-20221012185827886.png" alt="image-20221012185827886"></p><h4 id="12-2-1-对FCFS和SJF两种算法的思考"><a href="#12-2-1-对FCFS和SJF两种算法的思考" class="headerlink" title="12.2.1 对FCFS和SJF两种算法的思考"></a>12.2.1 对FCFS和SJF两种算法的思考</h4><p><img src="http://images.changzer.cn/image-20221012190030378.png" alt="image-20221012190030378"></p><h3 id="12-3-高响应比优先算法"><a href="#12-3-高响应比优先算法" class="headerlink" title="12.3 高响应比优先算法"></a>12.3 高响应比优先算法</h3><p><img src="http://images.changzer.cn/image-20221012190111328.png" alt="image-20221012190111328"></p><p><img src="http://images.changzer.cn/image-20221012190213377.png" alt="image-20221012190213377"></p><p><img src="http://images.changzer.cn/image-20221012190315866.png" alt="image-20221012190315866"></p><p><img src="http://images.changzer.cn/image-20221012190330533.png" alt="image-20221012190330533"></p><p><img src="http://images.changzer.cn/image-20221012190412526.png" alt="image-20221012190412526"></p><h3 id="12-4-时间片轮转（RR）"><a href="#12-4-时间片轮转（RR）" class="headerlink" title="12.4 时间片轮转（RR）"></a>12.4 时间片轮转（RR）</h3><p>通过就绪队列，时间一到就插到队尾</p><p><img src="http://images.changzer.cn/image-20221012190514750.png" alt="image-20221012190514750"></p><p><img src="http://images.changzer.cn/image-20221012190752570.png" alt="image-20221012190752570"></p><p><img src="http://images.changzer.cn/image-20221012190835215.png" alt="image-20221012190835215"></p><p><img src="http://images.changzer.cn/image-20221012191126537.png" alt="image-20221012191126537"></p><p><img src="http://images.changzer.cn/image-20221012191131736.png" alt="image-20221012191131736"></p><p><img src="http://images.changzer.cn/image-20221012191136175.png" alt="image-20221012191136175"></p><p><img src="http://images.changzer.cn/image-20221012191142663.png" alt="image-20221012191142663"></p><p><img src="http://images.changzer.cn/image-20221012191157091.png" alt="image-20221012191157091"></p><p>如果<strong>时间片太大</strong>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法<strong>退化为先来先服务</strong>调度算法，并且会<strong>增大进程响应时间</strong>，因此<strong>时间片不能太大</strong></p><p><img src="http://images.changzer.cn/Snipaste_2022-10-12_19-12-59.png" alt="Snipaste_2022-10-12_19-12-59"></p><p><img src="http://images.changzer.cn/image-20221012191344370.png" alt="image-20221012191344370"></p><h3 id="12-5-优先级调度算法"><a href="#12-5-优先级调度算法" class="headerlink" title="12.5 优先级调度算法"></a>12.5 优先级调度算法</h3><p><img src="http://images.changzer.cn/image-20221012191448545.png" alt="image-20221012191448545"></p><p><img src="http://images.changzer.cn/image-20221012192221897.png" alt="image-20221012192221897"></p><p><img src="http://images.changzer.cn/image-20221012192143187.png" alt="image-20221012192143187"></p><p>补充：就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以吧优先级高的进程排在更靠近队头的位置</p><p>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><p><strong>静态优先级</strong>：创建进程时确定，之后一直不变</p><p><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级</p><p>通常：</p><p>系统进程优先级<strong>高于</strong>用户进程</p><p>前台进程优先级<strong>高于</strong>后台进程</p><p>操作系统更偏好I&#x2F;O进程（或称I&#x2F;O繁忙型进程）</p><p><img src="http://images.changzer.cn/image-20221012192900573.png" alt="image-20221012192900573"></p><p>注：与I&#x2F;O型进程相对的是计算型进程（或称CPU繁忙型进程）</p><p>可以从追求公平、提升资源利用率等角度考虑</p><p>如果某进程在就绪队列中<strong>等待了很长时间</strong>，则可以适当<strong>提升</strong>其优先级</p><p>如果某进程占用处理机<strong>运行了很长时间</strong>则可适当<strong>降低</strong>其优先级</p><p>如果发现一个进程<strong>频繁地进行I&#x2F;O操作</strong>，则可适当<strong>提升</strong>其优先级</p><p><img src="http://images.changzer.cn/image-20221012193011895.png" alt="image-20221012193011895"></p><h3 id="12-6-多级反馈队列调度算法"><a href="#12-6-多级反馈队列调度算法" class="headerlink" title="12.6 多级反馈队列调度算法"></a>12.6 多级反馈队列调度算法</h3><p><img src="http://images.changzer.cn/image-20221012193028565.png" alt="image-20221012193028565"></p><p><img src="http://images.changzer.cn/image-20221012193324864.png" alt="image-20221012193324864"></p><p><img src="http://images.changzer.cn/image-20221012193416477.png" alt="image-20221012193416477"></p><p><img src="http://images.changzer.cn/image-20221012193425187.png" alt="image-20221012193425187"></p><p><img src="http://images.changzer.cn/image-20221012193431015.png" alt="image-20221012193431015"></p><p><strong>会导致饥饿</strong></p><p><img src="http://images.changzer.cn/image-20221012193731668.png" alt="image-20221012193731668"></p><p><img src="http://images.changzer.cn/image-20221012193742085.png" alt="image-20221012193742085"></p><h3 id="12-7-多级队列调度算法"><a href="#12-7-多级队列调度算法" class="headerlink" title="12.7 多级队列调度算法"></a>12.7 多级队列调度算法</h3><p><img src="http://images.changzer.cn/image-20221012193817662.png" alt="image-20221012193817662"></p><p><img src="http://images.changzer.cn/image-20221012193905835.png" alt="image-20221012193905835"></p><h2 id="13-进程同步、进程互斥"><a href="#13-进程同步、进程互斥" class="headerlink" title="13 进程同步、进程互斥"></a>13 进程同步、进程互斥</h2><h3 id="13-1-什么是进程同步"><a href="#13-1-什么是进程同步" class="headerlink" title="13.1 什么是进程同步"></a>13.1 什么是进程同步</h3><p>进程具有<strong>异步性</strong>的特征。异步性是指，各并发执行的进程以各自独立的、不可预知得到速度向前推进</p><p><img src="http://images.changzer.cn/image-20221012194008651.png" alt="image-20221012194008651"></p><p>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据-&gt;读数据”的顺序来执行</p><p><code>同步</code>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的工作次序而产生的<strong>制约关系</strong>。进程间的直接制约关系就是源于它们之间的相互合作</p><h3 id="13-2-什么是进程互斥"><a href="#13-2-什么是进程互斥" class="headerlink" title="13.2 什么是进程互斥"></a>13.2 什么是进程互斥</h3><p>进程的“并发：需要”共享“的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、又比如打印机、摄像头这样的I&#x2F;O设备）</p><p><img src="http://images.changzer.cn/image-20221012194107960.png" alt="image-20221012194107960"></p><p>我们把<strong>一个时间段内只允许一个进程使用的资源</strong>称为<code>临界资源</code>。许多物理设备都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源</p><p><strong>对临界资源得到访问，必须互斥地进行</strong>。<code>互斥</code>，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前<strong>访问临界资源的进程访问结束</strong>，释放该资源之后，另一个进程才<strong>能去访问临界资源</strong></p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><p><img src="http://images.changzer.cn/image-20221012194318482.png" alt="image-20221012194318482"></p><blockquote><p>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</p><p>临界区：访问临界资源的那段代码</p><p>退出区：负责解除正在访问临界资源的标志（可理解为：解锁“）</p><p>剩余区：做其他处理</p></blockquote><p>注意：</p><p>临界区是进程中访问临界资源的代码段</p><p>进入区和退出区是负责实现互斥的代码段</p><p>临界区也可称为“临界段”</p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循一下原则：</p><ol><li><p><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程<strong>立即进入</strong>临界区</p></li><li><p><strong>忙则等待</strong>。当已有进程进入临界区时，<strong>其他</strong>试图进入临界区的进程必须等待</p></li><li><p><strong>有限等待</strong>。对请求访问的进程，应保证在<strong>有限时间内进入</strong>临界区（保证不会饥饿）</p></li><li><p><strong>让权等待</strong>。当进程不能进入临界区时，<strong>应立即释放处理机</strong>，防止进程忙等待</p></li></ol><p><img src="http://images.changzer.cn/image-20221012194537606.png" alt="image-20221012194537606"></p><h2 id="14-进程互斥的软件实现方法"><a href="#14-进程互斥的软件实现方法" class="headerlink" title="14 进程互斥的软件实现方法"></a>14 进程互斥的软件实现方法</h2><h3 id="14-1-单标志法"><a href="#14-1-单标志法" class="headerlink" title="14.1 单标志法"></a>14.1 单标志法</h3><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><p><img src="http://images.changzer.cn/image-20221012195151459.png" alt="image-20221012195151459"></p><h3 id="14-2-双标志先检查法"><a href="#14-2-双标志先检查法" class="headerlink" title="14.2 双标志先检查法"></a>14.2 双标志先检查法</h3><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong>，比如“flag[0]&#x3D;true”意味着0号进程P0现在想要进入临界区。每个进程在<strong>进入临界区之前</strong>先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区</p><p><img src="http://images.changzer.cn/image-20221012195433244.png" alt="image-20221012195433244"></p><p><img src="http://images.changzer.cn/image-20221012195650923.png" alt="image-20221012195650923"></p><h3 id="14-3-双标志后检查法"><a href="#14-3-双标志后检查法" class="headerlink" title="14.3 双标志后检查法"></a>14.3 双标志后检查法</h3><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到了先<strong>“上锁“后”检查“</strong>的方法，来避免上述问题</p><p><img src="http://images.changzer.cn/image-20221012195802320.png" alt="image-20221012195802320"></p><p>如果按照1526的顺序执行，P0和P1都无法进入临界区</p><p><img src="http://images.changzer.cn/image-20221012200034508.png" alt="image-20221012200034508"></p><h3 id="14-4-Peterson算法"><a href="#14-4-Peterson算法" class="headerlink" title="14.4 Peterson算法"></a>14.4 Peterson算法</h3><p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）</p><p><img src="http://images.changzer.cn/image-20221012200102371.png" alt="image-20221012200102371"></p><p><img src="http://images.changzer.cn/image-20221012200312394.png" alt="image-20221012200312394"></p><p><img src="http://images.changzer.cn/image-20221012200318659.png" alt="image-20221012200318659"></p><h2 id="15-进程互斥的硬件实现方法"><a href="#15-进程互斥的硬件实现方法" class="headerlink" title="15 进程互斥的硬件实现方法"></a>15 进程互斥的硬件实现方法</h2><h3 id="15-1-中断屏蔽方法"><a href="#15-1-中断屏蔽方法" class="headerlink" title="15.1 中断屏蔽方法"></a>15.1 中断屏蔽方法</h3><p><strong>利用“开&#x2F; 关中断指令”</strong>实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><p><img src="http://images.changzer.cn/image-20221012200415474.png" alt="image-20221012200415474"></p><p>优点：简单、高效</p><p>缺点：不适用于多处理机：只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p><h3 id="15-2-TestAndSet指令"><a href="#15-2-TestAndSet指令" class="headerlink" title="15.2 TestAndSet指令"></a>15.2 TestAndSet指令</h3><p>简称TS指令，也有地方称为TestAndLock指令，或TSL指令</p><p>TSL指令是用<strong>硬件实现</strong>的，执行的过程<strong>不允许被中断</strong>，只能一气呵成。以下是用C语言描述的逻辑</p><p><img src="http://images.changzer.cn/image-20221012200511040.png" alt="image-20221012200511040"></p><p><img src="http://images.changzer.cn/image-20221012200516782.png" alt="image-20221012200516782"></p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会出现逻辑漏洞；适用于<strong>多处理机</strong>环境</p><p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致<strong>“忙等”</strong></p><h3 id="15-3-Swap指令"><a href="#15-3-Swap指令" class="headerlink" title="15.3 Swap指令"></a>15.3 Swap指令</h3><p>有的地方也叫EXchange指令，或简称XCHG指令</p><p>Swap指令是用<strong>硬件实现</strong>的，执行的过程<strong>不允许被中断</strong>，只能一气呵成。</p><p><img src="http://images.changzer.cn/image-20221012200807647.png" alt="image-20221012200807647"></p><p><img src="http://images.changzer.cn/image-20221012200813831.png" alt="image-20221012200813831"></p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</p><p><img src="http://images.changzer.cn/image-20221012201031779.png" alt="image-20221012201031779"></p><h2 id="16-互斥锁"><a href="#16-互斥锁" class="headerlink" title="16 互斥锁"></a>16 互斥锁</h2><h3 id="16-1-进程互斥：锁"><a href="#16-1-进程互斥：锁" class="headerlink" title="16.1 进程互斥：锁"></a>16.1 进程互斥：锁</h3><p>互斥锁</p><p>解决临界区最简单的工具就是互斥锁。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁</p><p>每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放</p><p><img src="http://images.changzer.cn/image-20221012201216129.png" alt="image-20221012201216129"></p><p>acquire或release的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现</p><p>互斥锁的<strong>主要缺点是忙等待</strong>，当有一个进程在临界区中，任何其他进程进入临界区时<strong>必须连续循环调用acquire</strong>。当多个进程共享同一个CPU时，就浪费了CPU周期。因此，互斥锁通<strong>常用于多处理器系统</strong>，一个线程可以在一个处理器上等待，不影响其他线程的执行</p><p>需要连续循环忙等的互斥锁，都可以称为<strong>自旋锁</strong>，如TSL指令、swap指令、单标志法</p><p>特性：</p><p>需忙等，进程时间片用完才下处理机，违反“让权等待”</p><p>优点：等待期间不用切换进程上下文，多处理器系统中，若<strong>上锁的时间短，则等待代价很低</strong></p><p>常用于多处理机系统，一个核忙等，其他核照常工作，并快速释放临界区</p><p>不太适用于单处理机系统，忙等的过程不可能解锁</p><p><img src="http://images.changzer.cn/image-20221012201445062.png" alt="image-20221012201445062"></p><h2 id="17-信号量机制"><a href="#17-信号量机制" class="headerlink" title="17 信号量机制"></a>17 信号量机制</h2><ol><li><p>在双标志先检查法中，进入区的：检查“、”上锁“操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题</p></li><li><p>所有的解决方案都无法实现“让权等待”</p></li></ol><h3 id="17-1-信号量机制"><a href="#17-1-信号量机制" class="headerlink" title="17.1 信号量机制"></a>17.1 信号量机制</h3><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量进行操作</strong>，从而很方便的实现了<strong>进程互斥</strong>、<strong>进程同步</strong></p><p><code>信号量</code>其实就是一个变量（可以是一个整数、也可以是更复杂的记录型变量），可以用一个信号量来<strong>表示系统某种资源的数量</strong>，比如系统中只有一台打印机，就可以设置一个初值为1的信号量</p><p><code>原语</code>是一种特殊的程序段，其执行只能<strong>一气呵成</strong>、<strong>不可被中断</strong>。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</p><p><img src="http://images.changzer.cn/image-20221012201902617.png" alt="image-20221012201902617"></p><p><img src="http://images.changzer.cn/image-20221012201907778.png" alt="image-20221012201907778"></p><p>整型信号量</p><p>用一个<strong>整数型的变量</strong>作为信号量，用来表示系统中<strong>某种资源的数量</strong></p><p>与普整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p><p><img src="http://images.changzer.cn/Snipaste_2022-10-12_20-20-55.png" alt="Snipaste_2022-10-12_20-20-55"></p><h3 id="17-2-记录型信号量"><a href="#17-2-记录型信号量" class="headerlink" title="17.2 记录型信号量"></a>17.2 记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量</p><p><img src="http://images.changzer.cn/image-20221012202328729.png" alt="image-20221012202328729"></p><blockquote><p>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中</p></blockquote><blockquote><p>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</p></blockquote><p><img src="http://images.changzer.cn/image-20221012202457366.png" alt="image-20221012202457366"></p><p><img src="http://images.changzer.cn/image-20221012202534596.png" alt="image-20221012202534596"></p><p><img src="http://images.changzer.cn/image-20221012202619642.png" alt="image-20221012202619642"></p><h2 id="18-用信号量实现进程互斥、同步、前驱关系"><a href="#18-用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="18 用信号量实现进程互斥、同步、前驱关系"></a>18 用信号量实现进程互斥、同步、前驱关系</h2><h3 id="18-1-信号量机制实现进程互斥"><a href="#18-1-信号量机制实现进程互斥" class="headerlink" title="18.1 信号量机制实现进程互斥"></a>18.1 信号量机制实现进程互斥</h3><p><img src="http://images.changzer.cn/image-20221012202738387.png" alt="image-20221012202738387"></p><p>注意：对<strong>不同临界资源需要设置不同的互斥信号量</strong></p><p><strong>P、V操作必须成对出现</strong>。缺少P就不能保证临界资源的互斥访问。缺少V会导致资源永不被释放，等待进程永不被唤醒。</p><h3 id="18-2-信号量机制实现进程同步"><a href="#18-2-信号量机制实现进程同步" class="headerlink" title="18.2 信号量机制实现进程同步"></a>18.2 信号量机制实现进程同步</h3><p>进程同步：要让各并发进程按要求有序地推进</p><p>1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</p><p>2.设置同步信号量S，初始为0</p><p>3.在“前操作”之后执行V(S)</p><p>4.在“后操作”之前执行P(S)</p><p><img src="http://images.changzer.cn/image-20221013143243373.png" alt="image-20221013143243373"></p><p><img src="http://images.changzer.cn/image-20221013143851686.png" alt="image-20221013143851686"></p><p>​保证了代码4 一定是在代码2 之后执行</p><h3 id="18-3-信号量机制实现前驱关系"><a href="#18-3-信号量机制实现前驱关系" class="headerlink" title="18.3 信号量机制实现前驱关系"></a>18.3 信号量机制实现前驱关系</h3><p><img src="http://images.changzer.cn/image-20221013144039770.png" alt="image-20221013144039770"></p><p><img src="http://images.changzer.cn/image-20221013144121620.png" alt="image-20221013144121620"></p><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p><ol><li><p>要为<strong>每一对前驱</strong>关系各设置一个<strong>同步信号量</strong></p></li><li><p>在<strong>“前操作”之后</strong>对相应的同步信号量<strong>执行V操作</strong></p></li><li><p>在<strong>“后操作”之后</strong>对相应的同步信号量<strong>执行P操作</strong></p></li></ol><p><img src="http://images.changzer.cn/image-20221013144221261.png" alt="image-20221013144221261"></p><p><img src="http://images.changzer.cn/image-20221013144346180.png" alt="image-20221013144346180"></p><h2 id="19-生产者-消费者问题"><a href="#19-生产者-消费者问题" class="headerlink" title="19 生产者-消费者问题"></a>19 生产者-消费者问题</h2><p><img src="http://images.changzer.cn/image-20221013144641190.png" alt="image-20221013144641190"></p><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p><p><strong>缓冲区是临界资源，各进程必须互斥访问</strong></p><h3 id="19-1-PV操作题目分析步骤"><a href="#19-1-PV操作题目分析步骤" class="headerlink" title="19.1 PV操作题目分析步骤"></a>19.1 PV操作题目分析步骤</h3><p>1.关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</p><p>2.整理思路。根据各进程的操作流程确定P、V操作的大致顺序</p><p>3.设置信号量。根据题目条件确定信号量初值（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p><p><img src="http://images.changzer.cn/image-20221013145500065.png" alt="image-20221013145500065"></p><p><img src="http://images.changzer.cn/image-20221013145505831.png" alt="image-20221013145505831"></p><p><img src="http://images.changzer.cn/image-20221013145528800.png" alt="image-20221013145528800"></p><h3 id="19-2-能否改变相邻P、V操作的顺序？"><a href="#19-2-能否改变相邻P、V操作的顺序？" class="headerlink" title="19.2 能否改变相邻P、V操作的顺序？"></a>19.2 能否改变相邻P、V操作的顺序？</h3><p><img src="http://images.changzer.cn/image-20221013145812534.png" alt="image-20221013145812534"></p><p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待着生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”</p><p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong></p><p>V操作不会导致进程阻塞，<strong>因此两个V操作顺序可以交换</strong></p><h2 id="20-吸烟者问题"><a href="#20-吸烟者问题" class="headerlink" title="20 吸烟者问题"></a>20 吸烟者问题</h2><p><img src="http://images.changzer.cn/image-20221013145956607.png" alt="image-20221013145956607"></p><p>这个题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p><p><strong>桌子</strong>可以抽象为容量为1的缓冲区，要<strong>互斥访问</strong></p><p><img src="http://images.changzer.cn/image-20221013150251077.png" alt="image-20221013150251077"></p><p><img src="http://images.changzer.cn/image-20221013150331346.png" alt="image-20221013150331346"></p><p>缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1</p><p><img src="http://images.changzer.cn/image-20221013150635169.png" alt="image-20221013150635169"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">provider()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>            P(finish);<br>            P(mutex);<br>            制作组合一;<br>            V(mutex);<br>            V(offer1)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>            P(finish);<br>            P(mutex);<br>            制作组合二;<br>            V(mutex);<br>            V(offer2)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>            P(finish);<br>            P(mutex);<br>            制作组合二;<br>            V(mutex);<br>            V(offer3)<br>        &#125;<br>        i += i % <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置</p><h2 id="21-读者写者问题"><a href="#21-读者写者问题" class="headerlink" title="21 读者写者问题"></a>21 读者写者问题</h2><h3 id="21-1-问题描述"><a href="#21-1-问题描述" class="headerlink" title="21.1 问题描述"></a>21.1 问题描述</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程或其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><p>1）<strong>允许多个读者</strong>可以同时对文件执行读操作</p><p>​读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据</p><p>2）<strong>只允许一个写者</strong>往文件中写信息</p><p>3）任一写者在完成写操作之前不允许其他读者或写者工作</p><p>4）写者执行写操作前，应让<strong>已有</strong>的读者和写者<strong>全部退出</strong></p><p>​读进程与写进程同时共享数据，可能导致读出的数据不一致的问题</p><p>​两个写进程同时共享数据，可能导致数据错误覆盖的问题</p><p><img src="http://images.changzer.cn/image-20221013152143910.png" alt="image-20221013152143910"></p><h3 id="21-2-如何实现"><a href="#21-2-如何实现" class="headerlink" title="21.2 如何实现"></a>21.2 如何实现</h3><p><img src="http://images.changzer.cn/image-20221013152205113.png" alt="image-20221013152205113"></p><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，<strong>读进程</strong>是<strong>优先</strong>的</p><p><img src="http://images.changzer.cn/image-20221013152517398.png" alt="image-20221013152517398"></p><p><img src="http://images.changzer.cn/image-20221013152633714.png" alt="image-20221013152633714"></p><p>结论：在这种算法中，连续进入读者可以同时读文件，写者和其他进程不能同时访问文件；写者不会饥饿，但也并<strong>不是真正的“写优先”</strong>，而是相对公平的先来先服务</p><p><img src="http://images.changzer.cn/image-20221013153104305.png" alt="image-20221013153104305"></p><h2 id="22-哲学家进餐问题"><a href="#22-哲学家进餐问题" class="headerlink" title="22 哲学家进餐问题"></a>22 哲学家进餐问题</h2><p><img src="http://images.changzer.cn/image-20221013153337302.png" alt="image-20221013153337302"></p><p><img src="http://images.changzer.cn/image-20221013153407491.png" alt="image-20221013153407491"></p><blockquote><p>如果5个哲学家并发地拿起了自己左手边的筷子，每位哲学家循环等待右边的人放下筷子（阻塞），发生了“死锁”</p></blockquote><p>如何防止死锁的发生呢？</p><p>1）可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><p>2）要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号刚好相反。用这种方式可以保证如果相邻的两个奇偶号哲学家都想吃放，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p><p>3）仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</p><p><img src="http://images.changzer.cn/image-20221013153929213.png" alt="image-20221013153929213"></p><blockquote><p>更准确的说法应该是：各哲学家<strong>拿筷子</strong>这件事必须<strong>互斥</strong>的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子</p></blockquote><p><img src="http://images.changzer.cn/image-20221013154825019.png" alt="image-20221013154825019"></p><h2 id="23-管程"><a href="#23-管程" class="headerlink" title="23 管程"></a>23 管程</h2><h3 id="23-1-为什么要引入管程"><a href="#23-1-为什么要引入管程" class="headerlink" title="23.1 为什么要引入管程"></a>23.1 为什么要引入管程</h3><p>信号量机制存在的问题：编写程序困难、易出错</p><p>如果写错了P操作的顺序，就可能会发生死锁</p><p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松？</p><h3 id="23-2-管程的定义和基本特征"><a href="#23-2-管程的定义和基本特征" class="headerlink" title="23.2 管程的定义和基本特征"></a>23.2 管程的定义和基本特征</h3><p>管程是一种特殊的软件模块，有这些部分组成：</p><p>1）局部于管程的<strong>共享数据结构</strong>说明</p><p>2）对该数据结构进行操作的<strong>一组过程</strong></p><p>3）对局部于管程的共享数据设置初始值的语句</p><p>4）管程有一个名字</p><h4 id="23-2-1-管程的基本特征："><a href="#23-2-1-管程的基本特征：" class="headerlink" title="23.2.1 管程的基本特征："></a>23.2.1 管程的基本特征：</h4><ol><li><p>局部于管程的数据只能被局部于管程的过程所访问</p></li><li><p>一个进程只有通过<strong>调用管程内的过程才能进入</strong>管程访问共享数据</p></li><li><p>每次<strong>仅允许一个进程</strong>在管程内执行<strong>某个内部过程</strong></p></li></ol><h3 id="23-1-拓展1：用管程解决生产者消费者问题"><a href="#23-1-拓展1：用管程解决生产者消费者问题" class="headerlink" title="23.1 拓展1：用管程解决生产者消费者问题"></a>23.1 拓展1：用管程解决生产者消费者问题</h3><p>伪代码：</p><blockquote><p> 管程中设置条件变量和等待&#x2F;唤醒操作，以解决同步问题</p></blockquote><p><img src="http://images.changzer.cn/Snipaste_2022-10-13_16-17-14.png" alt="Snipaste_2022-10-13_16-17-14"></p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步</p><ol><li><p>需要在管程中定义<strong>共享数据</strong>（如生产者消费者问题的缓冲区）</p></li><li><p>需要在管程中那个定义用于访问这些共享数据的<strong>“入口”</strong>——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</p></li><li><p>只有通过这些特定的“入口”才能访问共享数据</p></li><li><p>管程中有很多“入口”，但是每次<strong>只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多一个进程在访问缓冲区。<em>注意：这种互斥特性是由编译器负责实现的，程序员并不关心</em>）</p></li><li><p>可在管程中设置<strong>条件变量</strong>及<strong>等待&#x2F;唤醒</strong>操作以解决同步问题。可以让一个进程或线程在条件变量上等待<em>（此时，该进程应先释放管程的使用权，也就是让出“入口”）</em>：可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</p></li></ol><p><img src="http://images.changzer.cn/image-20221013162348186.png" alt="image-20221013162348186"></p><h3 id="23-1-拓展2：java中类似于管程的机制"><a href="#23-1-拓展2：java中类似于管程的机制" class="headerlink" title="23.1 拓展2：java中类似于管程的机制"></a>23.1 拓展2：java中类似于管程的机制</h3><p>java中，如果用关键字<code>synchronized</code>来描述一个函数，那么这个函数同一时间段只能被一个线程调用</p><p><img src="http://images.changzer.cn/image-20221013162850927.png" alt="image-20221013162850927"></p><p><img src="http://images.changzer.cn/image-20221013162906528.png" alt="image-20221013162906528"></p><h2 id="24-死锁的概念"><a href="#24-死锁的概念" class="headerlink" title="24 死锁的概念"></a>24 死锁的概念</h2><h3 id="24-1-什么是死锁"><a href="#24-1-什么是死锁" class="headerlink" title="24.1 什么是死锁"></a>24.1 什么是死锁</h3><p>哲学家进餐问题，每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都被阻塞，都无法向前推进的现象</strong>，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进</p><h3 id="24-2-死锁、饥饿、死循环的区别"><a href="#24-2-死锁、饥饿、死循环的区别" class="headerlink" title="24.2 死锁、饥饿、死循环的区别"></a>24.2 死锁、饥饿、死循环的区别</h3><p><code>死锁</code>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p><p><code>饥饿</code>：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先算法</p><p><code>死循环</code>：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的</p><p><img src="http://images.changzer.cn/image-20221013163314988.png" alt="image-20221013163314988"></p><h3 id="24-3-死锁产生的必要条件"><a href="#24-3-死锁产生的必要条件" class="headerlink" title="24.3 死锁产生的必要条件"></a>24.3 死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要其中<strong>任一条件不成立，死锁就不会发生</strong></p><ol><li><p><code>互斥条件</code>：只有对<strong>必须互斥使用的资源的争抢</strong>才会导致死锁。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</p></li><li><p><code>不剥夺条件</code>：进程所获得的的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放</p></li><li><p><code>请求和保持条件</code>：进程<strong>已经保持了至少一个资源</strong>，但又<strong>提出了新的资源请求</strong>，而该资源又被<strong>其他进程占有</strong>，此时请求进程<strong>被阻塞</strong>，但又对自己已有的资源<strong>保持不放</strong></p></li><li><p><code>循环等待的条件</code>：存在一种进程资源的<strong>循环等待链</strong>，链中的每一个进程已获得的资源被下一个进程所请求</p></li></ol><blockquote><p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待时死锁的必要不充分条件）</p></blockquote><p><img src="http://images.changzer.cn/image-20221013164303353.png" alt="image-20221013164303353"></p><h3 id="24-4-什么时候会发生死锁"><a href="#24-4-什么时候会发生死锁" class="headerlink" title="24.4 什么时候会发生死锁"></a>24.4 什么时候会发生死锁</h3><p><img src="http://images.changzer.cn/image-20221013164321209.png" alt="image-20221013164321209"></p><blockquote><p><strong>总之，对不可剥夺资源的不合理分配，可能导致死锁</strong></p></blockquote><h3 id="24-5-死锁的处理策略"><a href="#24-5-死锁的处理策略" class="headerlink" title="24.5 死锁的处理策略"></a>24.5 死锁的处理策略</h3><ol><li><p><code>预防死锁</code>。破坏死锁产生的四个必要条件中的一个或几个</p></li><li><p><code>避免死锁</code>。用某种方法防止进入不安全状态，从而避免死锁（银行家算法）</p></li><li><p><code>死锁的检测和解除</code>。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</p></li></ol><p><img src="http://images.changzer.cn/image-20221013164439421.png" alt="image-20221013164439421"></p><h4 id="24-5-1-预防死锁"><a href="#24-5-1-预防死锁" class="headerlink" title="24.5.1 预防死锁"></a>24.5.1 预防死锁</h4><h5 id="24-5-1-1-破坏互斥条件"><a href="#24-5-1-1-破坏互斥条件" class="headerlink" title="24.5.1.1 破坏互斥条件"></a>24.5.1.1 破坏互斥条件</h5><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术</p><p><img src="http://images.changzer.cn/image-20221013164616233.png" alt="image-20221013164616233"></p><blockquote><p>这个策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong></p></blockquote><h5 id="24-5-1-2-破坏不剥夺条件"><a href="#24-5-1-2-破坏不剥夺条件" class="headerlink" title="24.5.1.2 破坏不剥夺条件"></a>24.5.1.2 破坏不剥夺条件</h5><p><img src="http://images.changzer.cn/image-20221013164711145.png" alt="image-20221013164711145"></p><p><img src="http://images.changzer.cn/image-20221013164715218.png" alt="image-20221013164715218"></p><h5 id="24-5-1-3-破坏请求和保持条件"><a href="#24-5-1-3-破坏请求和保持条件" class="headerlink" title="24.5.1.3 破坏请求和保持条件"></a>24.5.1.3 破坏请求和保持条件</h5><p>可以采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源</p><p><img src="http://images.changzer.cn/image-20221013165103039.png" alt="image-20221013165103039"></p><h5 id="24-5-1-4-破坏循环等待条件"><a href="#24-5-1-4-破坏循环等待条件" class="headerlink" title="24.5.1.4 破坏循环等待条件"></a>24.5.1.4 破坏循环等待条件</h5><p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完</p><p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</p><p><img src="http://images.changzer.cn/image-20221013165203336.png" alt="image-20221013165203336"></p><p><img src="http://images.changzer.cn/image-20221013165737136.png" alt="image-20221013165737136"></p><h4 id="24-5-2-避免死锁（银行家算法）"><a href="#24-5-2-避免死锁（银行家算法）" class="headerlink" title="24.5.2 避免死锁（银行家算法）"></a>24.5.2 避免死锁（银行家算法）</h4><h5 id="24-5-2-1-什么是安全序列"><a href="#24-5-2-1-什么是安全序列" class="headerlink" title="24.5.2.1 什么是安全序列"></a>24.5.2.1 什么是安全序列</h5><p>所谓<code>安全序列</code>，就是指如果系统按照这种序列分配资源，则<strong>每个进程都能顺利完成</strong>。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个</p><p>如果分配资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就<strong>可能</strong>发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p><p>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求，这也是“银行家算法”的核心思想</p><h5 id="24-5-2-1-银行家算法"><a href="#24-5-2-1-银行家算法" class="headerlink" title="24.5.2.1 银行家算法"></a>24.5.2.1 银行家算法</h5><p>核心思想：在进程提出资源申请时，<strong>先预判此次分配是否会导致系统进入不安全状态</strong>。如果会进入<strong>不安全状态</strong>，就暂时不答应这次请求，让该进程<strong>先阻塞等待</strong></p><p><img src="http://images.changzer.cn/image-20221013170221944.png" alt="image-20221013170221944"></p><p><img src="http://images.changzer.cn/image-20221013170234774.png" alt="image-20221013170234774"></p><p><img src="http://images.changzer.cn/image-20221013170240470.png" alt="image-20221013170240470"></p><p><img src="http://images.changzer.cn/image-20221013170245817.png" alt="image-20221013170245817"></p><p><img src="http://images.changzer.cn/image-20221013170252506.png" alt="image-20221013170252506"></p><p><img src="http://images.changzer.cn/image-20221013170257307.png" alt="image-20221013170257307"></p><p><img src="http://images.changzer.cn/image-20221013170301966.png" alt="image-20221013170301966"></p><p><img src="http://images.changzer.cn/image-20221013170340277.png" alt="image-20221013170340277"></p><p><strong>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁</strong></p><h4 id="24-5-3-死锁的检测和解除"><a href="#24-5-3-死锁的检测和解除" class="headerlink" title="24.5.3 死锁的检测和解除"></a>24.5.3 死锁的检测和解除</h4><p>如果系统中不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><p>1）<code>死锁检测算法</code>：用于检测系统状态，以确定系统中<strong>是否发生了死锁</strong></p><p>2）<code>死锁解除算法</code>：当认定系统中已经发生了死锁，利用该算法可将系统<strong>从死锁状态中解脱出来</strong></p><h5 id="24-5-3-1-死锁的检测"><a href="#24-5-3-1-死锁的检测" class="headerlink" title="24.5.3.1 死锁的检测"></a>24.5.3.1 死锁的检测</h5><p>为了能对系统是否已发生了死锁进行检测，必须：</p><p>1）用<strong>某种数据结构</strong>来<strong>保存资源的请求和分配信息</strong></p><p>2）提供一种<strong>算法</strong>，利用上述信息来<strong>检测</strong>系统<strong>是否已进入死锁状态</strong></p><p><img src="http://images.changzer.cn/image-20221013170631375.png" alt="image-20221013170631375"></p><p><img src="http://images.changzer.cn/image-20221013170651253.png" alt="image-20221013170651253"></p><ol><li><p>如果系统中剩余的<strong>可用资源数足够满足进程的需求</strong>，那么这个进程暂时是不会阻塞的，可以顺利地执行下去</p></li><li><p>如果这个进程执行结束了就把资源<strong>归还系统</strong>，就可能使某些正在等待资源的进程被激活，并顺利地执行下去</p></li><li><p>相应的，这些被激活的进程<strong>执行完</strong>了之后<strong>又会归还一些资源</strong>，这样可能又会激活另外一些阻塞的进程</p></li></ol><p>如果按照上述过程，<strong>最终能消除所有边</strong>，就称这个图是可完全简化的。此时一定没有发生死锁（相当于一个安全序列）</p><ol start="4"><li>如果最终不能消除所有边，那么此时就是发生了死锁。<strong>最终还连着边的那些进程就是处于死锁状态的进程</strong></li></ol><p><img src="http://images.changzer.cn/image-20221013171751748.png" alt="image-20221013171751748"></p><p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时<strong>系统死锁</strong></p><h5 id="24-5-3-1-死锁的解除"><a href="#24-5-3-1-死锁的解除" class="headerlink" title="24.5.3.1 死锁的解除"></a>24.5.3.1 死锁的解除</h5><p>一旦检测出死锁的发生就应该立即解除死锁</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p><p>解除死锁的主要方法有：</p><ol><li><p><code>资源剥夺法</code>。<strong>挂起</strong>（暂时放在外存上）<strong>某些死锁进程</strong>，并抢占它的资源，将这些资源<strong>分配给其他的死锁进程</strong>。但是应该防止被挂起的进程长时间得不到资源而饥饿</p></li><li><p><code>撤销进程法</code>（或称终止进程法）。<strong>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。</strong>这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</p></li><li><p><code>进程回退法</code>。<strong>让一个或多个进程回退到足以避免死锁的地步。</strong>这就要求系统要记录进程的历史信息，设置还原点</p></li></ol><blockquote><p>如何决定“对谁动手”</p><ol><li><p>进程优先级</p></li><li><p>已执行多长时间</p></li><li><p>还要多久能完成</p></li><li><p>进程已经使用了多少资源</p></li><li><p>进程时交互式的还是批处理式的</p></li></ol></blockquote><p><img src="http://images.changzer.cn/image-20221013172156837.png" alt="image-20221013172156837"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统——（1）计算机系统概述</title>
    <link href="/2022/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-操作系统的概念和功能"><a href="#1-操作系统的概念和功能" class="headerlink" title="1 操作系统的概念和功能"></a>1 操作系统的概念和功能</h2><h3 id="1-1-操作系统的概念（定义）"><a href="#1-1-操作系统的概念（定义）" class="headerlink" title="1.1 操作系统的概念（定义）"></a>1.1 操作系统的概念（定义）</h3><p><img src="http://images.changzer.cn/image-20221008235138978.png" alt="image-20221008235138978"></p><p><img src="http://images.changzer.cn/image-20221008235621332.png" alt="image-20221008235621332"></p><p>（1）操作系统是系统资源的管理者</p><p>（2）向上层提供方便易用的服务</p><p>（3）是最接近硬件的软件</p><h3 id="1-2-操作系统的功能和目标"><a href="#1-2-操作系统的功能和目标" class="headerlink" title="1.2  操作系统的功能和目标"></a>1.2  操作系统的功能和目标</h3><h4 id="1-2-1-作为系统资源的管理者"><a href="#1-2-1-作为系统资源的管理者" class="headerlink" title="1.2.1 作为系统资源的管理者"></a>1.2.1 作为系统资源的管理者</h4><p>执行一个程序前需要将该程序放到内存中，才能被CPU处理</p><p><img src="http://images.changzer.cn/image-20221008235922715.png" alt="image-20221008235922715"></p><h4 id="1-2-2-向上层提供方便易用的服务"><a href="#1-2-2-向上层提供方便易用的服务" class="headerlink" title="1.2.2 向上层提供方便易用的服务"></a>1.2.2 向上层提供方便易用的服务</h4><p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p><p>GUI：图形化用户接口</p><p>用户可以使用形象的图形界面进行操作，而不再是需要记忆复杂的命令、参数</p><p>特点：用户说一句，系统跟着做一句</p><p>程序接口：可以在程序中进行<code>系统调用</code>来使用程序接口。普通用户不能直接使用程序接口，只能提供程序代码<code>间接</code>使用</p><p><img src="http://images.changzer.cn/image-20221009000728785.png" alt="image-20221009000728785"></p><p>系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式。</p><p><img src="http://images.changzer.cn/image-20221009000755662.png" alt="image-20221009000755662"></p><h4 id="1-2-3-作为最接近硬件的层次"><a href="#1-2-3-作为最接近硬件的层次" class="headerlink" title="1.2.3  作为最接近硬件的层次"></a>1.2.3  作为最接近硬件的层次</h4><p><img src="http://images.changzer.cn/image-20221009000944806.png" alt="image-20221009000944806"></p><p>通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。</p><p><img src="C:\Users\neiko\AppData\Roaming\Typora\typora-user-images\image-20221009001033717.png" alt="image-20221009001033717"></p><p><img src="http://images.changzer.cn/image-20221009001040546.png" alt="image-20221009001040546"></p><p><img src="C:\Users\neiko\AppData\Roaming\Typora\typora-user-images\image-20221009001118921.png" alt="image-20221009001118921"></p><blockquote><p>处理机管理：进程创建、进程控制、进程同步、调度</p><p>存储器管理：</p><p>​内存分配和回收</p><p>​内存保护（确保每个用户程序仅在自己的内存空间运行；绝对不允许用户程序访问操作系统的程序和数据）</p><p>​地址映射：逻辑地址转换为物理地址</p><p>​内存扩充(虚拟存储技术)：请求调入功能、置换功能</p><p>设备管理功能：</p><p>​主要任务：1、完成I&#x2F;O请求 2、提高CPU和I&#x2F;O设备的利用率</p><p>​缓冲管理：缓冲机制</p><p>​设备分配</p><p>​设备处理：设备驱动程序</p><p>文件管理功能：</p><p>​文件存储空间管理</p><p>​目录管理：按名存取</p><p>​文件的I&#x2F;O管理和保护</p><p>现代操作系统的新功能</p><p>​系统安全：认证技术、密码技术、访问控制技术、反病毒技术</p><p>​网络功能和服务：网络通信、资源通信、应用互操作</p><p>​支持多媒体：接纳控制技术、实时调度、多媒体文件的存储</p></blockquote><h2 id="2-操作系统的特征"><a href="#2-操作系统的特征" class="headerlink" title="2 操作系统的特征"></a>2 操作系统的特征</h2><h3 id="2-1-并发"><a href="#2-1-并发" class="headerlink" title="2.1 并发"></a>2.1 并发</h3><p>并发：指两个或多个事件在同一时间间隔发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>并行：指两个或多个事件在同一时刻同时发生。</p><img src="http://images.changzer.cn/image-20221009002352081.png" alt="image-20221009002352081" style="zoom:80%;" /><p>并发性是操作系统一个最基本的特征。</p><h3 id="2-2-共享"><a href="#2-2-共享" class="headerlink" title="2.2 共享"></a>2.2 共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><img src="http://images.changzer.cn/image-20221009002426862.png" alt="image-20221009002426862"></p><h4 id="2-2-1-并发和共享的关系"><a href="#2-2-1-并发和共享的关系" class="headerlink" title="2.2.1 并发和共享的关系"></a>2.2.1 并发和共享的关系</h4><p><code>并发性</code>是指计算机系统同时存在着多个运行着的程序。</p><p><code>共享性</code>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>如果失去并发性，则系统只有一个程序正在运行，则共享性失去存在的意义；</p><p>如果失去共享性，则两个程序不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</p><p>所以，并发和共享互为存在条件。</p><h3 id="2-3-虚拟"><a href="#2-3-虚拟" class="headerlink" title="2.3 虚拟"></a>2.3 虚拟</h3><p><code>虚拟</code>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上的对应物（后者）是用户感受到的。</p><p>虚拟存储器技术中的“空分复用技术”</p><p><img src="http://images.changzer.cn/image-20221009003156972.png" alt="image-20221009003156972"></p><p>虚拟技术中“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务。</p><p><img src="http://images.changzer.cn/image-20221009003215143.png" alt="image-20221009003215143"></p><p><strong>没有并发性，就谈不上虚拟性！！！</strong></p><h3 id="2-4-异步"><a href="#2-4-异步" class="headerlink" title="2.4 异步"></a>2.4 异步</h3><p><code>异步</code>是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停。以不可预知的速度向前推进，这就是进程的异步性。</p><p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。</p><p>只有系统拥有并发性，才有可能导致异步性<img src="http://images.changzer.cn/image-20221009003624487.png" alt="image-20221009003624487"></p><h2 id="3-操作系统的发展与分类"><a href="#3-操作系统的发展与分类" class="headerlink" title="3 操作系统的发展与分类"></a>3 操作系统的发展与分类</h2><h3 id="3-1-手工操作阶段"><a href="#3-1-手工操作阶段" class="headerlink" title="3.1 手工操作阶段"></a>3.1 手工操作阶段</h3><p>输入纸带，纸带机（打孔），计算机计算，输出纸带</p><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率低</p><h3 id="3-2-批处理阶段——单道批处理系统"><a href="#3-2-批处理阶段——单道批处理系统" class="headerlink" title="3.2 批处理阶段——单道批处理系统"></a>3.2 批处理阶段——单道批处理系统</h3><p>引入脱机输入&#x2F;输出技术（用外围机+磁带，通过外围机把程序提前存到磁带里），并由监督程序负责控制作业的输入、输出</p><p><img src="http://images.changzer.cn/image-20221009131215400.png" alt="image-20221009131215400"></p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</p><p>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序，CPU有大量的时间是在空闲等待I&#x2F;O完成。资源利用率依然很低</p><h3 id="3-3-批处理阶段——多道批处理系统"><a href="#3-3-批处理阶段——多道批处理系统" class="headerlink" title="3.3 批处理阶段——多道批处理系统"></a>3.3 批处理阶段——多道批处理系统</h3><p>操作系统正式诞生，用于支持多道程序并发运行</p><p>每次往内存中读入多道程序</p><p>主要优点：多道程序并发执行，共享计算机资源，<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，<strong>系统吞吐量大</strong></p><p>主要缺点：<strong>用户响应时间长，没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。没有在程序运行过程中输入一些参数）</p><blockquote><p>多道批处理系统需要解决的问题：</p><p>​处理机争用问题</p><p>​内存分配和保护问题</p><p>​I&#x2F;O设备分配问题</p><p>​文件的组织和管理问题</p><p>​作业管理问题</p><p>​用户与系统的接口问题</p></blockquote><h3 id="3-4-分时操作系统"><a href="#3-4-分时操作系统" class="headerlink" title="3.4 分时操作系统"></a>3.4 分时操作系统</h3><p><img src="http://images.changzer.cn/image-20221009131426836.png" alt="image-20221009131426836"></p><p>主要优点：用户请求可以被及时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立</p><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是完全公平的，循环为每个用户&#x2F;作业服务一个时间片，不区分任务的紧急性</p><h3 id="3-5-实时操作系统"><a href="#3-5-实时操作系统" class="headerlink" title="3.5 实时操作系统"></a>3.5 实时操作系统</h3><p><img src="http://images.changzer.cn/image-20221009131558502.png" alt="image-20221009131558502"></p><blockquote><p>实时任务的类型：</p><p>根据任务执行时是否呈现周期性来划分</p><p>根绝对截止时间的要求来划分</p></blockquote><p><img src="http://images.changzer.cn/image-20221009131606685.png" alt="image-20221009131606685"></p><h3 id="3-6-其他操作系统"><a href="#3-6-其他操作系统" class="headerlink" title="3.6 其他操作系统"></a>3.6 其他操作系统</h3><p><img src="http://images.changzer.cn/image-20221009131647290.png" alt="image-20221009131647290"></p><blockquote><p><strong>分布式操作系统：</strong></p><p>定义：基于软件实现的一种多处理机系统，是多个处理机通过通信线路互连而构成的松耦合系统</p><p>特征：分不行、透明性、同一性、全局性</p><p>功能：</p><p>单机处理机的功能</p><p>网络OS所拥有的全部功能</p><p>还包括：通信管理功能、资源管理功能、进程管理功能</p><p><strong>嵌入式系统：</strong></p><p>为了完成某个特定功能而设计的系统，或是有附加机制得到系统，或是其他部分的计算机硬件与软件的结合体</p><p>特点：系统内核小；具有可配置性</p><p><strong>微机操作系统</strong>：</p><p>单用户任务操作系统</p><p>单用户多任务操作系统</p><p>多用户多任务操作系统</p></blockquote><p><img src="http://images.changzer.cn/image-20221009131656507.png" alt="image-20221009131656507"></p><h2 id="4-操作系统的运行机制"><a href="#4-操作系统的运行机制" class="headerlink" title="4 操作系统的运行机制"></a>4 操作系统的运行机制</h2><p>程序是如何运行的？</p><p><img src="http://images.changzer.cn/image-20221009132237408.png" alt="image-20221009132237408"></p><p>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p><p>“指令”就是处理机能识别、执行的最基本命令</p><p><img src="http://images.changzer.cn/image-20221009132306224.png" alt="image-20221009132306224"></p><h3 id="4-1-特权指令VS非特权指令"><a href="#4-1-特权指令VS非特权指令" class="headerlink" title="4.1 特权指令VS非特权指令"></a>4.1 特权指令VS非特权指令</h3><p>操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”。如内存清零指令，这些指令影响重大，只允许“管理者”——即操作系统内核来使用</p><p>应用程序只能使用“非特权指令”</p><p>在CPU设计和生产的时候划分了特权和非特权指令，因此CPU执行一条指令前就能判断出其类型</p><h3 id="4-2-内核态VS用户态"><a href="#4-2-内核态VS用户态" class="headerlink" title="4.2 内核态VS用户态"></a>4.2 内核态VS用户态</h3><p><img src="http://images.changzer.cn/image-20221009132338452.png" alt="image-20221009132338452"></p><p>拓展：CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态（核心态、管态），0表示用户态（目态）</p><h3 id="4-3-内核态、用户态的切换"><a href="#4-3-内核态、用户态的切换" class="headerlink" title="4.3 内核态、用户态的切换"></a>4.3 内核态、用户态的切换</h3><p><img src="http://images.changzer.cn/image-20221009132433170.png" alt="image-20221009132433170"></p><p><img src="http://images.changzer.cn/image-20221009132535620.png" alt="image-20221009132535620"></p><p>除了非法使用特权指令之外，还有很多时间会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号</p><p><img src="http://images.changzer.cn/image-20221009132611123.png" alt="image-20221009132611123"></p><p><img src="http://images.changzer.cn/image-20221009132638323.png" alt="image-20221009132638323"></p><h2 id="5-中断和异常"><a href="#5-中断和异常" class="headerlink" title="5 中断和异常"></a>5 中断和异常</h2><h3 id="5-1-中断的作用"><a href="#5-1-中断的作用" class="headerlink" title="5.1 中断的作用"></a>5.1 中断的作用</h3><p>CPU 上会运行两种程序，一种是操作系统的内核程序，一种是应用程序</p><p>“中断”是让操作系统内核夺回CPU使用权的唯一途径</p><p>如果没有“中断”机制，那么一旦应用程序上CPU运行，COU就会一直运行这个应用程序</p><h3 id="5-2-中断的类型"><a href="#5-2-中断的类型" class="headerlink" title="5.2 中断的类型"></a>5.2 中断的类型</h3><h4 id="5-2-1-内中断"><a href="#5-2-1-内中断" class="headerlink" title="5.2.1 内中断"></a>5.2.1 内中断</h4><p>与当前执行的指令有关，中断信号来源于CPU内部</p><ol><li><p>若当前执行的指令是非法的，则会引发一个中断信号</p></li><li><p>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令(trap)，该指令会引发一个内部中断信号</p></li></ol><p>执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的。</p><h4 id="5-2-2-外中断"><a href="#5-2-2-外中断" class="headerlink" title="5.2.2 外中断"></a>5.2.2 外中断</h4><p>与当前执行的指令无关，中断信号来源于CPU外部</p><p>每一条指令执行结束时，CPU都会例行检查是否有外中断信号</p><p>1.时钟中断——由时钟部件（每隔一个时间片会给CPU发送一个时钟中断信号）发来的中断信号</p><p>2.I&#x2F;O中断——由输入&#x2F;输出设备发来的中断信号（当输入输出任务完成时，向CPU发送中断信号</p><p><img src="http://images.changzer.cn/image-20221009133348060.png" alt="image-20221009133348060"></p><h3 id="5-3-中断机制的基本原理"><a href="#5-3-中断机制的基本原理" class="headerlink" title="5.3 中断机制的基本原理"></a>5.3 中断机制的基本原理</h3><p><img src="http://images.changzer.cn/image-20221009133437913.png" alt="image-20221009133437913"></p><p><img src="http://images.changzer.cn/image-20221009133503907.png" alt="image-20221009133503907"></p><h2 id="6-系统调用"><a href="#6-系统调用" class="headerlink" title="6 系统调用"></a>6 系统调用</h2><h3 id="6-1-什么是系统调用，作用？"><a href="#6-1-什么是系统调用，作用？" class="headerlink" title="6.1 什么是系统调用，作用？"></a>6.1 什么是系统调用，作用？</h3><p><img src="http://images.changzer.cn/image-20221009133559774.png" alt="image-20221009133559774"></p><p><img src="http://images.changzer.cn/image-20221009133605473.png" alt="image-20221009133605473"></p><h3 id="6-2-系统调用与库函数的区别"><a href="#6-2-系统调用与库函数的区别" class="headerlink" title="6.2 系统调用与库函数的区别"></a>6.2 系统调用与库函数的区别</h3><p><img src="http://images.changzer.cn/image-20221009133659246.png" alt="image-20221009133659246"></p><h3 id="6-3-为什么系统调用是必须的？"><a href="#6-3-为什么系统调用是必须的？" class="headerlink" title="6.3 为什么系统调用是必须的？"></a>6.3 为什么系统调用是必须的？</h3><p>如果两个进程可以随意地、并发地共享打印机资源，会导致内容混杂在一起</p><p>解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，<strong>内核会对各个请求进行协调处理</strong></p><h3 id="6-4-什么功能要用到系统调用？"><a href="#6-4-什么功能要用到系统调用？" class="headerlink" title="6.4 什么功能要用到系统调用？"></a>6.4 什么功能要用到系统调用？</h3><p><img src="http://images.changzer.cn/image-20221009133819058.png" alt="image-20221009133819058"></p><p><img src="http://images.changzer.cn/image-20221009133830499.png" alt="image-20221009133830499"></p><h3 id="6-5-系统调用的过程"><a href="#6-5-系统调用的过程" class="headerlink" title="6.5 系统调用的过程"></a>6.5 系统调用的过程</h3><p><img src="http://images.changzer.cn/image-20221009133857760.png" alt="image-20221009133857760"></p><p>注意：1.<strong>陷入指令是在用户态执行的</strong>，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</p><p>​       2.发出系统调用<strong>请求是在用户态</strong>，对系统调用的相应处理是在<strong>核心态</strong>下进行</p><p><img src="http://images.changzer.cn/image-20221009133948745.png" alt="image-20221009133948745"></p><p><img src="http://images.changzer.cn/image-20221009133958224.png" alt="image-20221009133958224"></p><p><img src="http://images.changzer.cn/image-20221009134126178.png" alt="image-20221009134126178"></p><h2 id="7-操作系统的体系结构"><a href="#7-操作系统的体系结构" class="headerlink" title="7 操作系统的体系结构"></a>7 操作系统的体系结构</h2><h3 id="7-1-操作系统的内核"><a href="#7-1-操作系统的内核" class="headerlink" title="7.1 操作系统的内核"></a>7.1 操作系统的内核</h3><p><img src="http://images.changzer.cn/image-20221009134214446.png" alt="image-20221009134214446"></p><p>原语是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，不可被“中断”</p><p>内核是操作系统最基本、最核心的部分。实现操作系统功能的那些程序就是内核程序</p><p><img src="http://images.changzer.cn/image-20221009134246249.png" alt="image-20221009134246249"></p><p><img src="http://images.changzer.cn/image-20221009134307513.png" alt="image-20221009134307513"></p><p>注意：操作系统内核需要运行在内核态；操作系统的非内核功能运行在用户态</p><p><img src="http://images.changzer.cn/image-20221009134334848.png" alt="image-20221009134334848"></p><p>注意：<strong>变态的过程是有成本的</strong>，要消耗不少时间，频繁地变态<strong>会降低系统性能</strong></p><p><img src="http://images.changzer.cn/image-20221009134410612.png" alt="image-20221009134410612"></p><p><img src="http://images.changzer.cn/image-20221009134500210.png" alt="image-20221009134500210"></p><blockquote><p>模块化结构：</p><p>将OS按功能划分成若干模块，并规定好各模块间的接口，称为：模块-接口法“</p><p>优点：提高OS设计的正确性、可理解性和易维护性</p><p>​     增强OS的可适应性</p><p>​     加速OS的开发过程</p><p>大部分现代OS采用可加载的内核模块来设计</p><p>内核有一组核心组件，提供核心服务</p><p>其他服务可在内核运行时动态实现（动态链接）</p><p>每个组件在需要时被加载到内核</p><p>微内核OS结构</p><p>基本概念</p><p>足够小的内核 应用“机制与策略分裂”原理</p><p>基于客户&#x2F;服务器模式 采用面向对象技术</p><p>基本功能</p><p>进程管理、低级存储器管理、中断和陷入处理</p><p>微内核系统的优点和存在的问题</p><p>优点：提高了系统的可扩展性</p><p>增强了系统的可靠性</p><p>可移植性强</p><p>提供了对分布式系统的支持</p><p>融入了面向对象技术</p><p>缺点：运行效率有所降低</p><p>主要原因：在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和和进行用户&#x2F;内核模型与上下文的多次切换</p></blockquote><h2 id="8-操作系统引导"><a href="#8-操作系统引导" class="headerlink" title="8 操作系统引导"></a>8 操作系统引导</h2><p>操作系统引导——开机的时候，怎么让操作系统运行起来？</p><p><img src="http://images.changzer.cn/Snipaste_2022-10-09_13-46-13.png" alt="Snipaste_2022-10-09_13-46-13"></p><p><img src="http://images.changzer.cn/image-20221009134704626.png" alt="image-20221009134704626"></p><p>注：完整的操作系统初始化程序（即启动管理程序）可在个人目录下找到</p><h2 id="9-虚拟机"><a href="#9-虚拟机" class="headerlink" title="9 虚拟机"></a>9 虚拟机</h2><h3 id="9-1-传统计算机"><a href="#9-1-传统计算机" class="headerlink" title="9.1 传统计算机"></a>9.1 传统计算机</h3><p><img src="http://images.changzer.cn/image-20221009134744762.png" alt="image-20221009134744762"></p><h3 id="9-2-虚拟机"><a href="#9-2-虚拟机" class="headerlink" title="9.2 虚拟机"></a>9.2 虚拟机</h3><p><img src="http://images.changzer.cn/image-20221009134819994.png" alt="image-20221009134819994"></p><p><img src="http://images.changzer.cn/image-20221009134836404.png" alt="image-20221009134836404"></p><p><img src="http://images.changzer.cn/image-20221009134845312.png" alt="image-20221009134845312"></p><p><img src="http://images.changzer.cn/image-20221009134900851.png" alt="image-20221009134900851"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型的实现方法：类型擦除</title>
    <link href="/2022/10/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <url>/2022/10/08/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java泛型的实现方法：类型擦除"><a href="#一、Java泛型的实现方法：类型擦除" class="headerlink" title="一、Java泛型的实现方法：类型擦除"></a>一、Java泛型的实现方法：类型擦除</h1><p>大家都知道，Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p><p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是<code>List</code>，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是 Java 的泛型与 C++ 模板机制实现方式之间的重要区别。</p><p>通过两个例子证明Java类型的类型擦除</p><h2 id="1、原始类型相等"><a href="#1、原始类型相等" class="headerlink" title="1、原始类型相等"></a>1、原始类型相等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        list1.add(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        list2.add(<span class="hljs-number">123</span>);<br><br>        System.out.println(list1.getClass() == list2.getClass());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><h2 id="2、通过反射添加其它类型元素"><a href="#2、通过反射添加其它类型元素" class="headerlink" title="2、通过反射添加其它类型元素"></a>2、通过反射添加其它类型元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br><br>        list.add(<span class="hljs-number">1</span>);  <span class="hljs-comment">//这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br><br>        list.getClass().getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="hljs-string">&quot;asd&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(list.get(i));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><h1 id="二、类型擦除后保留的原始类型"><a href="#二、类型擦除后保留的原始类型" class="headerlink" title="二、类型擦除后保留的原始类型"></a>二、类型擦除后保留的原始类型</h1><p>在上面，两次提到了原始类型，什么是原始类型？</p><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其<strong>限定类型</strong>（无限定的变量用Object）替换。</p><h2 id="1、原始类型Object"><a href="#1、原始类型Object" class="headerlink" title="1、原始类型Object"></a>1、原始类型Object</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">private</span> T value;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T  value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>Pair的原始类型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object value;  <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object  value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>因为在<code>Pair&lt;T&gt;</code>中，T 是一个无限定的类型变量，所以用<code>Object</code>替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的<code>Pair</code>，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的<code>Pair</code>类型了，原始类型都是<code>Object</code>。</p><p>从上面的”一-2”中，我们也可以明白<code>ArrayList&lt;Integer&gt;</code>被擦除类型后，原始类型也变为<code>Object</code>，所以通过反射我们就可以存储字符串了。</p><p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p><p>比如: Pair这样声明的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么原始类型就是<code>Comparable</code>。</p><p>要区分<strong>原始类型</strong>和<strong>泛型变量的类型</strong>。</p><p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到 Object。</li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        <span class="hljs-comment">/**不指定泛型的时候*/</span>  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br>        <span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span><br><br>        <span class="hljs-comment">/**指定泛型的时候*/</span>  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br>        <span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float  </span><br>    &#125;  <br><br>    <span class="hljs-comment">//这是一个简单的泛型方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">add</span><span class="hljs-params">(T x,T y)</span>&#123;  <br>        <span class="hljs-keyword">return</span> y;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为<code>Object</code>，就比如<code>ArrayList</code>中，如果不指定泛型，那么这个<code>ArrayList</code>可以存储任意的对象。</p><h2 id="2、Object泛型"><a href="#2、Object泛型" class="headerlink" title="2、Object泛型"></a>2、Object泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    list.add(<span class="hljs-number">1</span>);  <br>    list.add(<span class="hljs-string">&quot;121&quot;</span>);  <br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <br>&#125;  <br></code></pre></td></tr></table></figure><h1 id="三、类型擦除引起的问题及解决方法"><a href="#三、类型擦除引起的问题及解决方法" class="headerlink" title="三、类型擦除引起的问题及解决方法"></a>三、类型擦除引起的问题及解决方法</h1><p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀问题，但是也引起来许多新问题，所以，SUN对这些问题做出了种种限制，避免我们发生各种错误。</p><h2 id="1、先检查再编译以及编译的对象和引用传递问题"><a href="#1、先检查再编译以及编译的对象和引用传递问题" class="headerlink" title="1、先检查再编译以及编译的对象和引用传递问题"></a>1、先检查再编译以及编译的对象和引用传递问题</h2><p><strong>Q</strong>: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p><p><strong>A</strong>: Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>    list.add(<span class="hljs-string">&quot;123&quot;</span>);  <br>    list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//编译错误  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的程序中，使用<code>add</code>方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为<code>Object</code>，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><p>那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。</p><p>以 ArrayList举例子，以前的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br></code></pre></td></tr></table></figure><p>现在的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <span class="hljs-comment">//第一种 情况</span><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//第二种 情况</span><br></code></pre></td></tr></table></figure><p>这样是没有错误的，不过会有个编译时警告。</p><p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p><p>因为类型检查就是编译时完成的，<code>new ArrayList()</code>只是在内存中开辟了一个存储空间，可以存储任何类型对象，而<strong>真正设计类型检查的是它的引用</strong>，因为我们是使用它引用<code>list1</code>来调用它的方法，比如说调用<code>add</code>方法，所以<code>list1</code>引用能完成泛型类型的检查。而引用<code>list2</code>没有使用泛型，所以不行。</p><p>举例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list1.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>        list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是Object  </span><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().add(<span class="hljs-number">22</span>); <span class="hljs-comment">//编译错误  </span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;().get(<span class="hljs-number">0</span>); <span class="hljs-comment">//返回类型就是String  </span><br>    &#125;  <br><br>&#125;  <br></code></pre></td></tr></table></figure><p>通过上面的例子，我们可以明白，<strong>类型检查就是针对引用的</strong>，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p><p>泛型中参数话类型为什么不考虑继承关系？</p><p>在Java中，像下面形式的引用传递是不允许的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;(); <span class="hljs-comment">//编译错误  </span><br>ArrayList&lt;Object&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(); <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>我们先看第一种情况，将第一种情况拓展成下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Object&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());  <br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());  <br>ArrayList&lt;String&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用<code>list2</code>引用用<code>get()</code>方法取值的时候，返回的都是<code>String</code>类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了<code>Object</code>类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p><p>再看第二种情况，将第二种情况拓展成下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());  <br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());<br><br>ArrayList&lt;Object&gt; list2 = list1; <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure><p>没错，这样的情况比第一种情况好的多，最起码，在我们用<code>list2</code>取值的时候不会出现<code>ClassCastException</code>，因为是从<code>String</code>转换为<code>Object</code>。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用<code>list2</code>往里面<code>add()</code>新的对象，那么到时候取得时候，我怎么知道我取出来的到底是<code>String</code>类型的，还是<code>Object</code>类型的呢？</p><p><strong>所以，要格外注意，泛型中的引用传递的问题。</strong></p><h2 id="2、自动类型转换"><a href="#2、自动类型转换" class="headerlink" title="2、自动类型转换"></a>2、自动类型转换</h2><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p><p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p><p>看下<code>ArrayList.get()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br><br>    RangeCheck(index);  <br><br>    <span class="hljs-keyword">return</span> (E) elementData[index];  <br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在<code>return</code>之前，会根据泛型变量进行强转。假设泛型类型变量为<code>Date</code>，虽然泛型信息会被擦除掉，但是会将<code>(E) elementData[index]</code>，编译为<code>(Date) elementData[index]</code>。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设<code>Pair</code>类的<code>value</code>域是<code>public</code>的，那么表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> pair.value;<br></code></pre></td></tr></table></figure><p>也会自动地在结果字节码中插入强制类型转换。</p><h2 id="3、类型擦除与多态的冲突和解决方法"><a href="#3、类型擦除与多态的冲突和解决方法" class="headerlink" title="3、类型擦除与多态的冲突和解决方法"></a>3、类型擦除与多态的冲突和解决方法</h2><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;  <br><br>    <span class="hljs-keyword">private</span> T value;  <br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们想要一个子类继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Date&gt; &#123;  <br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">super</span>.setValue(value);  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为<code>Date</code>，那么父类里面的两个方法的参数都为<code>Date</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> value;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.value = value;  <br>&#125;<br></code></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型<code>Object</code>，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;  <br>    <span class="hljs-keyword">private</span> Object value;  <br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object  value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>再看子类的两个重写的方法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>    <span class="hljs-built_in">super</span>.setValue(value);  <br>&#125;  <br><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>&#125;<br></code></pre></td></tr></table></figure><p>先来分析<code>setValue</code>方法，父类的类型是<code>Object</code>，而子类的类型是<code>Date</code>，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。</p><p>我们在一个main方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;  <br>        <span class="hljs-type">DateInter</span> <span class="hljs-variable">dateInter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateInter</span>();  <br>        dateInter.setValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());                  <br>        dateInter.setValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()); <span class="hljs-comment">//编译错误  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果是重载，那么子类中两个<code>setValue</code>方法，一个是参数<code>Object</code>类型，一个是<code>Date</code>类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。</p><p>为什么会这样呢？</p><p>原因是这样的，我们传入父类的泛型类型是<code>Date，Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;  <br>    <span class="hljs-keyword">private</span> Date value;  <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> value;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.value = value;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p><p>可是由于种种原因，虚拟机并不能将泛型类型变为<code>Date</code>，只能将类型擦除掉，变为原始类型<code>Object</code>。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的<code>Date</code>类型参数的方法啊。</p><p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是<strong>桥方法</strong>。</p><p>首先，我们用<code>javap -c className</code>的方式反编译下<code>DateInter</code>子类的字节码，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs class">class com.tao.test.DateInter extends com.tao.test.Pair&lt;java.util.Date&gt; &#123;  <br>  com.tao.test.DateInter();  <br>    Code:  <br>       0: aload_0  <br>       1: invokespecial #8                  // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  <br>       4: return  <br><br>  public void setValue(java.util.Date);  //我们重写的setValue方法  <br>    Code:  <br>       0: aload_0  <br>       1: aload_1  <br>       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  <br>       5: return  <br><br>  public java.util.Date getValue();    //我们重写的getValue方法  <br>    Code:  <br>       0: aload_0  <br>       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  <br>       4: checkcast     #26                 // class java/util/Date  <br>       7: areturn  <br><br>  public java.lang.Object getValue();     //编译时由编译器生成的桥方法  <br>    Code:  <br>       0: aload_0  <br>       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  <br>       4: areturn  <br><br>  public void setValue(java.lang.Object);   //编译时由编译器生成的桥方法  <br>    Code:  <br>       0: aload_0  <br>       1: aload_1  <br>       2: checkcast     #26                 // class java/util/Date  <br>       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  <br>       8: return  <br>&#125;<br></code></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写<code>setValue</code>和<code>getValue</code>方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而在我们自己定义的<code>setvalue</code>和<code>getValue</code>方法上面的<code>@Oveerride</code>只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p><p>所以，<strong>虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突</strong>。</p><p>不过，要提到一点，这里面的<code>setValue</code>和<code>getValue</code>这两个桥方法的意义又有不同。</p><p><code>setValue</code>方法是为了解决类型擦除与多态之间的冲突。</p><p>而<code>getValue</code>却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p><p>那么父类的<code>getValue</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> value;  <br>&#125;<br></code></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>&#125;<br></code></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p><p>关于协变：。。。。。。</p><p>并且，还有一点也许会有疑问，子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><h2 id="4、泛型类型变量不能是基本数据类型"><a href="#4、泛型类型变量不能是基本数据类型" class="headerlink" title="4、泛型类型变量不能是基本数据类型"></a>4、泛型类型变量不能是基本数据类型</h2><p>不能用类型参数替换基本类型。就比如，没有<code>ArrayList&lt;double&gt;</code>，只有<code>ArrayList&lt;Double&gt;</code>。因为当类型擦除后，<code>ArrayList</code>的原始类型变为<code>Object</code>，但是<code>Object</code>类型不能存储<code>double</code>值，只能引用<code>Double</code>的值。</p><h2 id="5、编译时集合的instanceof"><a href="#5、编译时集合的instanceof" class="headerlink" title="5、编译时集合的instanceof"></a>5、编译时集合的instanceof</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>因为类型擦除之后，<code>ArrayList&lt;String&gt;</code>只剩下原始类型，泛型信息<code>String</code>不存在了。</p><p>那么，编译时进行类型查询的时候使用下面的方法是错误的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>( arrayList <span class="hljs-keyword">instanceof</span> ArrayList&lt;String&gt;)<br></code></pre></td></tr></table></figure><h2 id="6、泛型在静态方法和静态类中的问题"><a href="#6、泛型在静态方法和静态类中的问题" class="headerlink" title="6、泛型在静态方法和静态类中的问题"></a>6、泛型在静态方法和静态类中的问题</h2><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>&lt;T&gt; &#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T one;   <span class="hljs-comment">//编译错误    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  T <span class="hljs-title function_">show</span><span class="hljs-params">(T one)</span>&#123; <span class="hljs-comment">//编译错误    </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p><p>但是要注意区分下面的一种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>&lt;T&gt; &#123;    <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T &gt;T <span class="hljs-title function_">show</span><span class="hljs-params">(T one)</span>&#123; <span class="hljs-comment">//这是正确的    </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p><p>转自：<a href="http://blog.csdn.net/wisgood/article/details/11762427">http://blog.csdn.net/wisgood/article/details/11762427</a></p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>类型擦除</tag>
      
      <tag>泛型类型</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java.lang.NoClassDefFoundError：javax/xml/bind/DatatypeConverter错误出现原因以及解决方式</title>
    <link href="/2022/10/05/BUG%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94java.lang.NoClassDefFoundError%20javaxxmlbindDatatypeConverter%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/05/BUG%E4%BF%AE%E5%A4%8D%E2%80%94%E2%80%94java.lang.NoClassDefFoundError%20javaxxmlbindDatatypeConverter%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="java-lang-NoClassDefFoundError-javax-x2F-xml-x2F-bind-x2F-DatatypeConverter错误出现原因以及解决方式"><a href="#java-lang-NoClassDefFoundError-javax-x2F-xml-x2F-bind-x2F-DatatypeConverter错误出现原因以及解决方式" class="headerlink" title="java.lang.NoClassDefFoundError: javax&#x2F;xml&#x2F;bind&#x2F;DatatypeConverter错误出现原因以及解决方式"></a>java.lang.NoClassDefFoundError: javax&#x2F;xml&#x2F;bind&#x2F;DatatypeConverter错误出现原因以及解决方式</h1><p>今天在使用JDK 17 环境下使用jjwt时候出现了这个错误，错误日志如下：</p><p><img src="http://images.changzer.cn/image-20221005193551610.png" alt="image-20221005193551610"></p><p>故障原因：</p><blockquote><p><em>JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。</em><br><em>java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包</em><br><em>而在 java 6&#x2F;7 &#x2F; 8 时关于这个API 都是捆绑在一起的</em></p></blockquote><h4 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h4><p>降低JDK 版本到 JDK 8</p><h4 id="解决方案二-（亲测可行）"><a href="#解决方案二-（亲测可行）" class="headerlink" title="解决方案二:（亲测可行）"></a>解决方案二:（亲测可行）</h4><p>手动加入这些依赖Jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUG修复</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习写一个MYDB——（1）从TM开始</title>
    <link href="/2022/09/28/%E5%AD%A6%E4%B9%A0%E5%86%99%E4%B8%80%E4%B8%AAMYDB%E2%80%94%E2%80%94%EF%BC%881%EF%BC%89%E4%BB%8ETM%E5%BC%80%E5%A7%8B/"/>
    <url>/2022/09/28/%E5%AD%A6%E4%B9%A0%E5%86%99%E4%B8%80%E4%B8%AAMYDB%E2%80%94%E2%80%94%EF%BC%881%EF%BC%89%E4%BB%8ETM%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1、从TM开始"><a href="#1、从TM开始" class="headerlink" title="1、从TM开始"></a>1、从TM开始</h1><p><strong>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</strong></p><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>  在MYDB中，每一个事务都有XID，XID唯一标识了这个事务。</p><p>事务的XID是从1开始标号，并自增，不可重复。特殊XID 0 为超级事务。当一些操作想在没申请事务的情况下进行，可以将操作的 XID 设置为 0。XID为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p><p>  1、active，正在运行，尚未结束</p><p>  2、commited，已提交</p><p>  3、aborted，已撤销（回滚）</p><hr><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><p>XID文件内容如下：</p><p><img src="http://images.changzer.cn/image_1.8eee7392.png" alt="image_1.8eee7392"></p><p>定义 TransactionManager 接口供其他模块调用，用来创建事务和查询事务状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionManager</span> &#123; <br> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 开启一个新事务 </span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>; <span class="hljs-comment">// 提交一个事务 </span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>; <span class="hljs-comment">// 取消一个事务 </span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>; <span class="hljs-comment">// 查询一个事务的状态是否是正在进行的状态 </span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCommitted</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>; <span class="hljs-comment">// 查询一个事务的状态是否是已提交 </span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAborted</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>; <span class="hljs-comment">// 查询一个事务的状态是否是已取消 </span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 关闭TM </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先定义一些必要的常量和成员变量：</p><p>文件读写都采用了 NIO 方式的 FileChannel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionManager</span>&#123;<br><br><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br><br>TransactionManagerImpl(RandomAccessFile raf, FileChannel fc) &#123;<br><span class="hljs-built_in">this</span>.file = raf;<br><span class="hljs-built_in">this</span>.fc = fc;<br>counterLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>checkXIDCounter();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查XID文件是否合法，读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查XID文件是否合法</span><br><span class="hljs-comment">     * 读取XID_FILE_HEADER中的xidcounter，根据它计算文件的理论长度，对比实际长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>fileLen = file.length(); <span class="hljs-comment">//返回文件的字节数</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>        <span class="hljs-keyword">try</span> &#123;<br>            fc.position(<span class="hljs-number">0</span>);<br>            fc.read(buf);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>); <span class="hljs-comment">//计算理论的字节长度</span><br>        <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>            Panic.panic(Error.BadXIDFileException);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>计算理论的字节长度（当前 xid 状态所在位置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过&#x3D;&#x3D;getXidPosition(long xid) &#x3D;&#x3D;方法获取当前xid状态在文件中的位置，并更新xid的状态为 &#x3D;&#x3D;status&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新完 xid 的状态后还需要更新 xid 文件的头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将XID加一，并更新XID Header</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>开始事务：先使用 ReentrantLock 上锁，将当前 xid 的状态记录为 0 ，并增加head头部的xid信息，最后释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123;<br>    counterLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xidCounter + <span class="hljs-number">1</span>;<br>        updateXID(xid, FIELD_TRAN_ACTIVE);<br>        incrXIDCounter();<br>        <span class="hljs-keyword">return</span> xid;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        counterLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提交操作和撤销操作同理，只需要修改当前 xid 的状态即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    updateXID(xid, FIELD_TRAN_COMMITTED);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    updateXID(xid, FIELD_TRAN_ABORTED);<br>&#125;<br></code></pre></td></tr></table></figure><p>检测XID事务是否处于status状态，先用<code>getXidPosition()</code>方法找到当前 xid 状态存放的位置，FeilChannal 移动到状态位置处，读取当前状态，再与<code>status</code>比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure><p>检测是否是正在进行、已提交、撤回同理，只需要调用<code>checkXID()</code>方法传入对应的参数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">if</span>(xid == SUPER_XID) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> checkXID(xid, FIELD_TRAN_ACTIVE);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCommitted</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">if</span>(xid == SUPER_XID) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> checkXID(xid, FIELD_TRAN_COMMITTED);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAborted</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">if</span>(xid == SUPER_XID) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> checkXID(xid, FIELD_TRAN_ABORTED);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是关闭操作了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.close();<br>        file.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManagerTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">transCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">noWorkers</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">noWorks</span> <span class="hljs-operator">=</span> <span class="hljs-number">3000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> TransactionManager tmger;<br>    <span class="hljs-keyword">private</span> Map&lt;Long, Byte&gt; transMap;<br>    <span class="hljs-keyword">private</span> CountDownLatch cdl;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiThread</span><span class="hljs-params">()</span> &#123;<br>tmger = TransactionManager.create(<span class="hljs-string">&quot;E:\\学习\\test\\tmp\\tranmger_test&quot;</span>);<br>        transMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        cdl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(noWorkers);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; noWorkers; i ++) &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; worker();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).run();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            cdl.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//tmger.close();</span><br><span class="hljs-keyword">assert</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\学习\\test\\tmp\\tranmger_test.xid&quot;</span>).delete();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">worker</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">inTrans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">transXID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; noWorks; i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> Math.abs(random.nextInt(<span class="hljs-number">6</span>));<br>            <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span>(inTrans == <span class="hljs-literal">false</span>) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tmger.begin();<br>                    transMap.put(xid, (<span class="hljs-type">byte</span>)<span class="hljs-number">0</span>);<br>                    transCnt ++;<br>                    transXID = xid;<br>                    inTrans = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> (random.nextInt(Integer.MAX_VALUE) % <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">switch</span>(status) &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                            tmger.commit(transXID);<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                            tmger.abort(transXID);<br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    transMap.put(transXID, (<span class="hljs-type">byte</span>)status);<br>                    inTrans = <span class="hljs-literal">false</span>;<br>                &#125;<br>                lock.unlock();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span>(transCnt &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">long</span> xid=(<span class="hljs-type">long</span>)((random.nextInt(Integer.MAX_VALUE)%transCnt) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">byte</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transMap.get(xid);<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">switch</span> (status) &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                            ok = tmger.isActive(xid);<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                            ok = tmger.isCommitted(xid);<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                            ok = tmger.isAborted(xid);<br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">assert</span> ok;<br>                &#125;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>        cdl.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>学习写一个MYDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>MYDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习java虚拟机——（4）内存模型</title>
    <link href="/2022/09/27/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%944%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/09/27/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%944%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="1-java-内存模型"><a href="#1-java-内存模型" class="headerlink" title="1. java 内存模型"></a>1. java 内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p>JMM 体现在以下几个方面</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>保证指令不会受到线程上下文切换的影响</p><ul><li>解决办法</li></ul><p>synchronized （同步关键字）</p><p>语法:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>( 对象 ) &#123;<br>  要作为原子操作代码<br><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对 象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</li><li>synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</li><li>但缺点synchronized是属于重量级操作，性能相对更低</li></ul></blockquote><h3 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 <strong>可见性</strong></h3><p>保证指令不会受 cpu 缓存的影响</p><p>  main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <br>        <span class="hljs-keyword">while</span>(run)&#123;<br>    <br>        <span class="hljs-comment">// ....</span><br>    <br>        &#125;<br><br><br>      &#125;);<br>    <br>      t.start();<br><br><br>​      <br><br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>    <br>      run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br><br><br>    &#125;<br></code></pre></td></tr></table></figure>1. 初始状态， t 线程刚开始从主内存**读取**了 run 的值到工作内存。2. 因为 t 线程要**频繁**从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的**高速缓存**中，减少对主存中 run 的访问，提高效率</code></pre><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是<strong>旧值</strong></li></ol><ul><li>解决办法</li></ul><p><strong>volatile（易变关键字）</strong></p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><blockquote><p>是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况</p></blockquote><h3 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h3><p>保证指令不会受 cpu 指令并行优化的影响</p><h4 id="1-3-1-诡异的结果"><a href="#1-3-1-诡异的结果" class="headerlink" title="1.3.1 诡异的结果"></a>1.3.1 诡异的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>  <span class="hljs-keyword">if</span>(ready) &#123;<br><br>    r.r1 = num + num;<br><br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    r.r1 = <span class="hljs-number">1</span>;<br><br><br>  &#125;<br><br><br>&#125;<br><br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>  num = <span class="hljs-number">2</span>;<br><br>  ready = <span class="hljs-literal">true</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><ul><li>有同学这么分析</li></ul><p>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><ul><li>结果还有可能是 0 ！</li></ul><p>这种情况下是：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行</p><p>num &#x3D; 2</p><p>这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><blockquote><p>创建骨架项目：<br>mvn archetype:generate -DinteractiveMode&#x3D;false -<br>DarchetypeGroupId&#x3D;org.openjdk.jcstress -DarchetypeArtifactId&#x3D;jcstress-java-test-<br>archetype -DgroupId&#x3D;org.sample -DartifactId&#x3D;test -Dversion&#x3D;1.0</p></blockquote><p>创建 maven 项目，提供如下测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <br><br>  <span class="hljs-meta">@Actor</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br><br>      r.r1 = num + num;<br><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      r.r1 = <span class="hljs-number">1</span>;<br><br><br>    &#125;<br><br><br>  &#125;<br><br>  <br><br>  <span class="hljs-meta">@Actor</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br><br>    num = <span class="hljs-number">2</span>;<br><br>    ready = <span class="hljs-literal">true</span>;<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">mvn clean <span class="hljs-keyword">install</span><br>java -jar <span class="hljs-keyword">target</span>/jcstress.jar<br></code></pre></td></tr></table></figure><p>出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><ul><li><strong>解决办法</strong></li></ul><p>**volatile **修饰的变量，可以禁用指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <br><br>  <span class="hljs-meta">@Actor</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br><br>      r.r1 = num + num;<br><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      r.r1 = <span class="hljs-number">1</span>;<br><br><br>    &#125;<br><br><br>  &#125;<br><br>  <br><br>  <span class="hljs-meta">@Actor</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br><br>    num = <span class="hljs-number">2</span>;<br><br>    ready = <span class="hljs-literal">true</span>;<br><br><br>  &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mercury">*** INTERESTING tests<br>Some interesting behaviors observed. This <span class="hljs-keyword">is</span> for the plain curiosity.<br><span class="hljs-number">0</span> matching test results.<br></code></pre></td></tr></table></figure><h3 id="1-3-2-有序性理解"><a href="#1-3-2-有序性理解" class="headerlink" title="1.3.2 有序性理解"></a>1.3.2 有序性理解</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br><br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行 时，既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...; <br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br></code></pre></td></tr></table></figure><p>这种特性称之为『<strong>指令重排</strong>』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br><br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br><br>      <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br><br>        <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br><br>          INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br><br>        &#125;<br><br><br>      &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> INSTANCE;<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li></ul><p>但在多线程环境下，上面的代码是有问题的， INSTANCE &#x3D; new Singleton() 对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> <span class="hljs-comment">// class cn/itcast/jvm/t4/Singleton</span><br><span class="hljs-number">3</span>: dup<br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">7</span>: putstatic #<span class="hljs-number">4</span> <span class="hljs-comment">// Field</span><br>INSTANCE:Lcn/itcast/jvm/t4/Singleton;<br></code></pre></td></tr></table></figure><p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：先将引用地址赋值给 INSTANCE 变量后，再执行 构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">时间<span class="hljs-number">1</span> <span class="hljs-built_in">t1</span> 线程执行到 <span class="hljs-keyword">INSTANCE </span>= new Singleton();<br>时间<span class="hljs-number">2</span> <span class="hljs-built_in">t1</span> 线程分配空间，为Singleton对象生成了引用地址（<span class="hljs-number">0</span> 处）<br>时间<span class="hljs-number">3</span> <span class="hljs-built_in">t1</span> 线程将引用地址赋值给 <span class="hljs-keyword">INSTANCE，这时 </span><span class="hljs-keyword">INSTANCE </span>!= null（<span class="hljs-number">7</span> 处）<br>时间<span class="hljs-number">4</span> <span class="hljs-built_in">t2</span> 线程进入getInstance() 方法，发现 <span class="hljs-keyword">INSTANCE </span>!= null（<span class="hljs-keyword">synchronized块外），直接</span><br><span class="hljs-keyword"></span>返回 <span class="hljs-keyword">INSTANCE</span><br><span class="hljs-keyword"></span>时间<span class="hljs-number">5</span> <span class="hljs-built_in">t1</span> 线程执行Singleton的构造方法（<span class="hljs-number">4</span> 处）<br></code></pre></td></tr></table></figure><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h3 id="1-3-3-happens-before"><a href="#1-3-3-happens-before" class="headerlink" title="1.3.3 happens-before"></a>1.3.3 happens-before</h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  <span class="hljs-keyword">synchronized</span>(m) &#123;<br><br>    x = <span class="hljs-number">10</span>;<br><br><br>  &#125;<br><br><br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  <span class="hljs-keyword">synchronized</span>(m) &#123;<br><br>    System.out.println(x);<br><br><br>  &#125;<br><br><br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  x = <span class="hljs-number">10</span>;<br><br><br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  System.out.println(x);<br><br><br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  System.out.println(x);<br><br><br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>  x = <span class="hljs-number">10</span>;<br><br><br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通 过t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>      <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br><br>        System.out.println(x);<br><br>        <span class="hljs-keyword">break</span>;<br><br><br>      &#125;<br><br><br>    &#125;<br><br><br>  &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>  t2.start();<br><br>  <br><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br><br>      Thread.sleep(<span class="hljs-number">1000</span>);<br><br><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>      e.printStackTrace();<br><br><br>    &#125;<br><br>    x = <span class="hljs-number">10</span>;<br><br>    t2.interrupt();<br><br><br>  &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>  <br><br>  <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br><br>    Thread.yield();<br><br><br>  &#125;<br><br>  System.out.println(x);<br><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</li></ul><h2 id="2-CAS-与-原子类"><a href="#2-CAS-与-原子类" class="headerlink" title="2. CAS 与 原子类"></a>2. CAS 与 原子类</h2><h3 id="2-1-CAS"><a href="#2-1-CAS" class="headerlink" title="2.1 CAS"></a>2.1 CAS</h3><p>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执 行 +1 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要不断尝试</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-type">int</span> 旧值 = 共享变量 ; <span class="hljs-comment">// 比如拿到了当前值 0</span><br><br>  <span class="hljs-type">int</span> 结果 = 旧值 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1</span><br><br>  <br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    compareAndSwap 返回 false，重新尝试，直到：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  */</span><br><br>  <br><br>  <span class="hljs-keyword">if</span>( compareAndSwap ( 旧值, 结果 )) &#123;<br><br>    <span class="hljs-comment">// 成功，退出循环</span><br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul><p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令</p><h3 id="2-2-乐观锁与悲观锁"><a href="#2-2-乐观锁与悲观锁" class="headerlink" title="2.2 乐观锁与悲观锁"></a>2.2 乐观锁与悲观锁</h3><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><h3 id="2-3-原子操作类"><a href="#2-3-原子操作类" class="headerlink" title="2.3 原子操作类"></a>2.3 原子操作类</h3><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、</p><p>AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p><p>可以使用 AtomicInteger 改写之前的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建原子整数对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br><br>      i.getAndIncrement(); <span class="hljs-comment">// 获取并且自增 i++</span><br><br>      <span class="hljs-comment">// i.incrementAndGet(); // 自增并且获取 ++i</span><br><br><br>    &#125;<br><br><br>  &#125;);<br><br>  <br><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br><br>      i.getAndDecrement(); <span class="hljs-comment">// 获取并且自减 i--</span><br><br><br>    &#125;<br><br><br>  &#125;);<br><br>  <br><br>  t1.start();<br><br>  t2.start();<br><br>  t1.join();<br><br>  t2.join();<br><br>  System.out.println(i);<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-synchronized-优化"><a href="#3-synchronized-优化" class="headerlink" title="3. synchronized 优化"></a>3. synchronized 优化</h2><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为 标记位 、 线程锁记录指针 、 重量级锁指针 、 线程ID 等内容</p><h3 id="3-1-轻量级锁"><a href="#3-1-轻量级锁" class="headerlink" title="3.1 轻量级锁"></a>3.1 轻量级锁</h3><p>如果一个对象虽然有多线程访问，但<strong>多线程访问的时间是错开的</strong>（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比：</p><p>学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。</p><p>如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即<strong>升级为重量级锁</strong>，进入重量级锁的流程。</p><p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><br>    <span class="hljs-comment">// 同步块 A</span><br><br>    method2();<br><br><br>  &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><br>    <span class="hljs-comment">// 同步块 B</span><br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><table><thead><tr><th>线程 1</th><th>对象 Mark Word</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>访问同步块 B，把 Mark 复制到 线程 1 的锁记录</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>00（轻量锁）线程 1锁记录地址</td><td>-</td></tr><tr><td>执行同步块 A</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>执行同步块 B</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 B 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>同步块 A 执行完毕</td><td>00（轻量锁）线程 1 锁记录地址</td><td>-</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>-</td></tr><tr><td>-</td><td>01（无锁）</td><td>访问同步块 A，把 Mark 复制到线程 2 的锁记录</td></tr><tr><td>-</td><td>- 01（无锁）</td><td>CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td>地址</td><td>00（轻量锁）线程 2 锁记录地址</td><td>成功（加锁）</td></tr><tr><td>00（轻量锁）线程 1</td><td>…</td><td>…</td></tr></tbody></table><h3 id="3-2-锁膨胀"><a href="#3-2-锁膨胀" class="headerlink" title="3.2 锁膨胀"></a>3.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻</p><p>量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><br>    <span class="hljs-comment">// 同步块</span><br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>线程 1</th><th>对象 Mark</th><th>线程 2</th></tr></thead><tbody><tr><td>访问同步块，把 Mark 复制到线程1 的锁记录</td><td>01（无锁）</td><td>-</td></tr><tr><td>CAS 修改 Mark 为线程 1 锁记录地址</td><td>01（无锁）</td><td>-</td></tr><tr><td>成功（加锁）</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>访问同步块，把 Mark 复制 到线程 2</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>CAS 修改 Mark 为线程 2 锁 记录地址</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>失败（发现别人已经占了锁）</td></tr><tr><td>执行同步块</td><td>00（轻量锁）线程 1 锁 记录地址</td><td>CAS 修改 Mark 为重量锁</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>失败（解锁）</td><td>10（重量锁）重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁，唤起阻塞线程竞争</td><td>01（无锁）</td><td>阻塞中</td></tr><tr><td>-</td><td>10（重量锁）</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10（重量锁）</td><td>成功（加锁）</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="3-3-重量锁"><a href="#3-3-重量锁" class="headerlink" title="3.3 重量锁"></a>3.3 重量锁</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><p>自旋重试成功的情况</p><table><thead><tr><th>线程 1 （cpu 1 上）</th><th>对象 Mark</th><th>线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块 获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td>-</td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><p>自旋重试失败的情况</p><table><thead><tr><th>线程 1（cpu 1 上）</th><th>对象 Mark</th><th>线程 2（cpu 2 上）</th></tr></thead><tbody><tr><td>-</td><td>10（重量锁）</td><td>-</td></tr><tr><td>访问同步块 获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>…</td><td>…</td></tr></tbody></table><h3 id="3-4-偏向锁"><a href="#3-4-偏向锁" class="headerlink" title="3.4 偏向锁"></a>3.4 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID是自己的就表示没有竞争，不用重新 CAS.</p><ul><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li><li>访问对象的 hashCode 也会撤销偏向锁</li><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</li><li>撤销偏向和重偏向都是批量进行的，以类为单位</li><li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li></ul><p>可以参考这篇论文：<a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp149958.pdf">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp149958.pdf</a></p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><br>    <span class="hljs-comment">// 同步块 A</span><br><br>    method2();<br><br><br>  &#125;<br><br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br><br>    <span class="hljs-comment">// 同步块 B</span><br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>线程 1</th><th>对象 Mark</th></tr></thead><tbody><tr><td>访问同步块 A，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象 hashCode</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块 B，检查 Mark 中是否有线程 ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程 ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块 B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象 hashCode</td></tr></tbody></table><h3 id="3-5-其它优化"><a href="#3-5-其它优化" class="headerlink" title="3.5 其它优化"></a>3.5 其它优化</h3><ol><li><strong>减少上锁时间</strong></li></ol><p>同步代码块中尽量短</p><ol start="2"><li><strong>减少锁的粒度</strong></li></ol><p>ConcurrentHashMap</p><ul><li>ConcurrentHashMap</li><li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li><li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li></ul><ol start="3"><li><strong>锁粗化</strong></li></ol><p>多次循环进入同步块不如同步块内多次循环</p><p>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>().append(<span class="hljs-string">&quot;a&quot;</span>).append(<span class="hljs-string">&quot;b&quot;</span>).append(<span class="hljs-string">&quot;c&quot;</span>) ;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>锁消除</strong></li></ol><p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p><ol start="5"><li><strong>读写分离</strong></li></ol><p>CopyOnWriteArrayList</p><p>ConyOnWriteSet</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_50280576/article/details/113532093">https://blog.csdn.net/weixin_50280576/article/details/113532093</a></p><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></p><p><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/">http://luojinping.com/2015/07/09/java锁优化/</a></p><p><a href="https://www.infoq.cn/article/java-se-16-synchronized">https://www.infoq.cn/article/java-se-16-synchronized</a></p><p><a href="https://www.jianshu.com/p/9932047a89be">https://www.jianshu.com/p/9932047a89be</a></p><p><a href="https://www.cnblogs.com/sheeva/p/6366782.html">https://www.cnblogs.com/sheeva/p/6366782.html</a></p><p><a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>]]></content>
    
    
    <categories>
      
      <category>学习java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习java虚拟机——（3）类加载与字节码技术</title>
    <link href="/2022/09/18/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%943%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/09/18/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%943%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h1><h2 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h2><p>一个简单的 HelloWorld.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二进制字节码（类基本信息，常量池，类方法定义，包含了虚拟机指令）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 javac -parameters -d . HellowWorld.java</p><p>编译为 HelloWorld.class 后是这个样子的：</p><p><img src="http://images.changzer.cn/image_1.5759b2b9.png"></p><p>根据 JVM 规范，类文件结构如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ClassFile &#123;<br>    u4           magic<span class="hljs-comment">;</span><br>    u2           minor_version<span class="hljs-comment">;</span><br>    u2           major_version<span class="hljs-comment">;</span><br>    u2           constant_pool_count<span class="hljs-comment">;</span><br>    cp           _info constant_pool[constant_pool_count-<span class="hljs-number">1</span>]<span class="hljs-comment">; </span><br>    u2           access_flags<span class="hljs-comment">;</span><br>    u2           this_class<span class="hljs-comment">;</span><br>    u2           super_class<span class="hljs-comment">;</span><br>    u2           interfaces_count<span class="hljs-comment">;</span><br>    u2           interfaces[interfaces_count]<span class="hljs-comment">;</span><br>    u2           fields_count<span class="hljs-comment">;</span><br>    field_info   fields[fields_count]<span class="hljs-comment">;</span><br>    u2           methods_count<span class="hljs-comment">;</span><br>    method_info  methods[methods_count]<span class="hljs-comment">;</span><br>    u2           attributes_count<span class="hljs-comment">;</span><br>    attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><p>0~3 字节，表示它是否是【class】类型的文件</p><p>0000000 <code>ca fe ba be</code> 00 00 00 34 00 23 0a 00 06 00 15 09</p><p>ca fe ba be ：意思是 .class 文件，不同的东西有不同的魔数，比如 jpg、png 图片等！</p><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8</p><p>0000000 ca fe ba be <code>00 00 00 34</code> 00 23 0a 00 06 00 15 09</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h3><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td>CONSTANT_Class</td><td>7</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td></tr><tr><td>CONSTANT_String</td><td>8</td></tr><tr><td>CONSTANT_Integer</td><td>3</td></tr><tr><td>CONSTANT_Float</td><td>4</td></tr><tr><td>CONSTANT_Long</td><td>5</td></tr><tr><td>CONSTANT_Double</td><td>6</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td></tr><tr><td>CONSTANT_Utf8</td><td>1</td></tr><tr><td>CONSTANT_MethodHandle</td><td>15</td></tr><tr><td>CONSTANT_MethodType</td><td>16</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td></tr></tbody></table><p><img src="http://images.changzer.cn/image_2.e5a09e22.png"></p><p><img src="http://images.changzer.cn/image_3.2638db48.png"></p><p><img src="http://images.changzer.cn/image_4.c274b640.png"></p><p><img src="http://images.changzer.cn/image_5.ccb17ded.png"></p><p><img src="http://images.changzer.cn/image_6.039a4559.png"></p><p><img src="http://images.changzer.cn/image_7.55f12505.png"></p><p><img src="http://images.changzer.cn/image_8.5d794cfc.png"></p><p><img src="http://images.changzer.cn/image_9.6909532f.png"></p><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><p><img src="http://images.changzer.cn/image_10.686ef17e.png"></p><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>Declared public ; may be accessed from outside its package.</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>Declared final ; no subclasses allowed.</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>Is an interface not a class.</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>Declared abstract ; must not be instantiated.</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>Declared as an annotation type.</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>Declared as an enum type.</td></tr></tbody></table><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><p>表示成员变量数量，本类为 0</p><p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><table><thead><tr><th>FieldType</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L ClassName ;</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>表示方法数量，本类为 2</p><p>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><p>一个方法由 访问修饰符，名称，参数描述，方法属性数量，方法属性组成</p><p><img src="http://images.changzer.cn/image_11.e0eb1b7d.png"></p><p><img src="http://images.changzer.cn/image_12.6bfdb547.png"></p><p><img src="http://images.changzer.cn/image_13.ec4eca7b.png"></p><p><img src="http://images.changzer.cn/image_14.3392ddb2.png"></p><p><img src="http://images.changzer.cn/image_15.fae357d7.png"></p><h3 id="1-7-附加属性"><a href="#1-7-附加属性" class="headerlink" title="1.7 附加属性"></a>1.7 附加属性</h3><p><img src="http://images.changzer.cn/image_16.0b04dc86.png"></p><p>参考文献 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>b7 &#x3D;&gt; invokespecial 预备调用构造方法，哪个方法呢？</p><ol><li>2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</li><li>b7 &#x3D;&gt; invokespecial 预备调用构造方法，哪个方法呢？</li><li>00 01 引用常量池中 #1 项，即【<code>Method java/lang/Object.&quot;&quot;:()V</code>】</li><li>b1 表示返回</li></ol><p><img src="http://images.changzer.cn/image_1.6ca31881.png"></p><p>请参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件</p><p><img src="http://images.changzer.cn/image_2.e4347769.png"></p><p><img src="http://images.changzer.cn/image_3.2aa70344.png"></p><p><img src="http://images.changzer.cn/image_4.8ebd8284.png"></p><p><img src="http://images.changzer.cn/image_5.4cee2c23.png"></p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_1</span> &#123;    <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <br>  <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br>  <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;        <br>  System.out.println(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-1-常量池载入运行时常量池"><a href="#2-3-1-常量池载入运行时常量池" class="headerlink" title="2.3.1 常量池载入运行时常量池"></a>2.3.1 常量池载入运行时常量池</h4><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="http://images.changzer.cn/image_6.4db48534.png"></p><h4 id="2-3-2-方法字节码载入方法区"><a href="#2-3-2-方法字节码载入方法区" class="headerlink" title="2.3.2 方法字节码载入方法区"></a>2.3.2 方法字节码载入方法区</h4><p><img src="http://images.changzer.cn/image_7.63fafbef.png"></p><h4 id="2-3-3-main-线程开始运行，分配栈帧内存"><a href="#2-3-3-main-线程开始运行，分配栈帧内存" class="headerlink" title="2.3.3 main 线程开始运行，分配栈帧内存"></a>2.3.3 main 线程开始运行，分配栈帧内存</h4><p>（stack&#x3D;2，locals&#x3D;4） 对应操作数栈有 2 个空间（每个空间 4 个字节），局部变量表中有 4 个槽位。</p><p><img src="http://images.changzer.cn/image_8.305e985d.png"></p><h4 id="2-3-4-执行引擎开始执行字节码"><a href="#2-3-4-执行引擎开始执行字节码" class="headerlink" title="2.3.4 执行引擎开始执行字节码"></a>2.3.4 执行引擎开始执行字节码</h4><p><strong>bipush 10</strong></p><ul><li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有</li><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul><p><img src="http://images.changzer.cn/image_9.d975956e.png"></p><h4 id="2-3-5-istore-1"><a href="#2-3-5-istore-1" class="headerlink" title="2.3.5 istore_1"></a>2.3.5 istore_1</h4><p>将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>对应代码中的 a &#x3D; 10</p><p><img src="http://images.changzer.cn/image_10.7218ee2d.png"></p><p><img src="http://images.changzer.cn/image_11.9bffc959.png"></p><h4 id="2-3-6-ldc-3"><a href="#2-3-6-ldc-3" class="headerlink" title="2.3.6 ldc #3"></a>2.3.6 ldc #3</h4><ul><li>从常量池加载 #3 数据到操作数栈</li><li>注意 Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算 好的</li></ul><p><img src="http://images.changzer.cn/image_12.2c31db23.png"></p><h4 id="2-3-7-istore-2"><a href="#2-3-7-istore-2" class="headerlink" title="2.3.7 istore_2"></a>2.3.7 istore_2</h4><p>将操作数栈中的元素弹出，放到局部变量表的 2 号位置</p><p><img src="http://images.changzer.cn/image_13.005ea238.png"></p><p><img src="http://images.changzer.cn/image_14.90d291fa.png"></p><h4 id="2-3-8-iload-1"><a href="#2-3-8-iload-1" class="headerlink" title="2.3.8 iload_1"></a>2.3.8 iload_1</h4><p>将局部变量表中 1 号位置和 2 号位置的元素放入操作数栈中。因为只能在操作数栈中执行运算操作</p><p><img src="http://images.changzer.cn/image_15.98c0b959.png"></p><h4 id="2-3-9-iload-2"><a href="#2-3-9-iload-2" class="headerlink" title="2.3.9 iload_2"></a>2.3.9 iload_2</h4><p><img src="http://images.changzer.cn/image_16.aaf9827a.png"></p><h4 id="2-3-10-iadd"><a href="#2-3-10-iadd" class="headerlink" title="2.3.10 iadd"></a>2.3.10 iadd</h4><p>将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中。</p><p><img src="http://images.changzer.cn/image_17.6480e150.png"></p><p><img src="http://images.changzer.cn/image_18.264d74f8.png"></p><h4 id="2-3-11-istore-3"><a href="#2-3-11-istore-3" class="headerlink" title="2.3.11 istore_3"></a>2.3.11 istore_3</h4><p>将操作数栈中的元素弹出，放入局部变量表的3号位置。</p><p><img src="http://images.changzer.cn/image_19.6f0ec581.png"></p><p><img src="http://images.changzer.cn/image_20.0ae5a119.png"></p><h4 id="2-3-12-getstatic-4"><a href="#2-3-12-getstatic-4" class="headerlink" title="2.3. 12 getstatic #4"></a>2.3. 12 getstatic #4</h4><p>在运行时常量池中找到 #4 ，发现是一个对象，在堆内存中找到该对象，并将其引用放入操作数栈中</p><p><img src="http://images.changzer.cn/image_21.e4563418.png"></p><p><img src="http://images.changzer.cn/image_22.53567637.png"></p><h4 id="2-3-13-iload-3"><a href="#2-3-13-iload-3" class="headerlink" title="2.3.13 iload_3"></a>2.3.13 iload_3</h4><p>将局部变量表中 3 号位置的元素压入操作数栈中。</p><p><img src="http://images.changzer.cn/image_23.7f7fbf7e.png"></p><p><img src="http://images.changzer.cn/image_24.4847fa8e.png"></p><h4 id="2-3-14-invokevirtual-5"><a href="#2-3-14-invokevirtual-5" class="headerlink" title="2.3.14 invokevirtual #5"></a>2.3.14 invokevirtual #5</h4><ul><li>找到常量池 #5 项</li><li>定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</li><li>生成新的栈帧（分配 locals、stack等）</li><li>传递参数，执行新栈帧中的字节码</li></ul><p><img src="http://images.changzer.cn/image_25.e39bc73d.png"></p><ul><li>执行完毕，弹出栈帧</li><li>清除 main 操作数栈内容</li></ul><p><img src="http://images.changzer.cn/image_26.5654584c.png"></p><h4 id="2-3-15-return"><a href="#2-3-15-return" class="headerlink" title="2.3.15 return"></a>2.3.15 return</h4><ul><li>完成 main 方法调用，弹出 main 栈帧</li><li>程序结束</li></ul><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习-分析 i++"></a>2.4 练习-分析 i++</h3><p>目的：从字节码角度分析 a++ 相关题目</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从字节码角度分析 a++ 相关题目</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_2</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a++ + ++a + a--;<br>  System.out.println(a);<br>  System.out.println(b);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">(0x0009)</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><br><br>  <span class="hljs-attr">Code:</span><br><br>  <span class="hljs-string">stack\=2,</span> <span class="hljs-string">locals\=3,</span> <span class="hljs-string">args\_size\=1</span><br><br>    <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">10</span><br><br>    <span class="hljs-attr">2:</span> <span class="hljs-string">istore_1</span><br><br>    <span class="hljs-attr">3:</span> <span class="hljs-string">iload_1</span><br><br>    <span class="hljs-attr">4:</span> <span class="hljs-string">iinc</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-attr">7:</span> <span class="hljs-string">iinc</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-attr">10:</span> <span class="hljs-string">iload_1</span><br><br>    <span class="hljs-attr">11:</span> <span class="hljs-string">iadd</span><br><br>    <span class="hljs-attr">12:</span> <span class="hljs-string">iload_1</span><br><br>    <span class="hljs-attr">13:</span> <span class="hljs-string">iinc</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">-1</span><br><br>    <span class="hljs-attr">16:</span> <span class="hljs-string">iadd</span><br><br>    <span class="hljs-attr">17:</span> <span class="hljs-string">istore_2</span><br><br>    <span class="hljs-attr">18:</span> <span class="hljs-string">getstatic</span> <span class="hljs-comment">#2 // Field</span><br><br><br>  <span class="hljs-string">java/lang/System.out:Ljava/io/PrintStream;</span><br><br>    <span class="hljs-attr">21:</span> <span class="hljs-string">iload_1</span><br><br>    <span class="hljs-attr">22:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#3 // Method</span><br><br><br>  <span class="hljs-string">java/io/PrintStream.println:(I)V</span><br><br>    <span class="hljs-attr">25:</span> <span class="hljs-string">getstatic</span> <span class="hljs-comment">#2 // Field</span><br><br><br>  <span class="hljs-string">java/lang/System.out:Ljava/io/PrintStream;</span><br><br>    <span class="hljs-attr">28:</span> <span class="hljs-string">iload_2</span><br><br>    <span class="hljs-attr">29:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#3 // Method</span><br><br><br>  <span class="hljs-string">java/io/PrintStream.println:(I)V</span><br><br>    <span class="hljs-attr">32:</span> <span class="hljs-string">return</span><br><br><br>  <span class="hljs-attr">LineNumberTable:</span><br><br>    <span class="hljs-attr">line 8:</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-attr">line 9:</span> <span class="hljs-number">3</span><br><br>    <span class="hljs-attr">line 10:</span> <span class="hljs-number">18</span><br><br>    <span class="hljs-attr">line 11:</span> <span class="hljs-number">25</span><br><br>    <span class="hljs-attr">line 12:</span> <span class="hljs-number">32</span><br><br><br>  <span class="hljs-attr">LocalVariableTable:</span><br><br>    <span class="hljs-string">Start</span> <span class="hljs-string">Length</span> <span class="hljs-string">Slot</span> <span class="hljs-string">Name</span> <span class="hljs-string">Signature</span><br><br>      <span class="hljs-number">0</span> <span class="hljs-number">33</span> <span class="hljs-number">0</span> <span class="hljs-string">args</span> <span class="hljs-string">\[Ljava/lang/String;</span><br><br>      <span class="hljs-number">3</span> <span class="hljs-number">30</span> <span class="hljs-number">1</span> <span class="hljs-string">a</span> <span class="hljs-string">I</span><br><br>      <span class="hljs-number">18</span> <span class="hljs-number">15</span> <span class="hljs-number">2</span> <span class="hljs-string">b</span> <span class="hljs-string">I</span><br><br><br><br><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>注意 iinc 指令是直接在局部变量 slot 上进行运算</li><li>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</li></ul><p><img src="http://images.changzer.cn/image_27.bed110f6.png"></p><p><img src="http://images.changzer.cn/image_28.fce3e978.png"></p><p><img src="http://images.changzer.cn/image_29.908f9186.png"></p><p><img src="http://images.changzer.cn/image_30.7fde4a60.png"></p><p><img src="http://images.changzer.cn/image_31.8cb0ce61.png"></p><p><img src="http://images.changzer.cn/image_32.6343985b.png"></p><p><img src="http://images.changzer.cn/image_33.fdfdd61a.png"></p><p><img src="http://images.changzer.cn/image_34.d28982fd.png"></p><p><img src="http://images.changzer.cn/image_35.c398d133.png"></p><p><img src="http://images.changzer.cn/image_36.9ab5dff0.png"></p><p><img src="http://images.changzer.cn/image_37.3a9fb02f.png"></p><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><table><thead><tr><th>指令</th><th>助记符</th><th>含义</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>判断是否 &#x3D;&#x3D; 0</td></tr><tr><td>0x9a</td><td>ifne</td><td>判断是否 !&#x3D; 0</td></tr><tr><td>0x9b</td><td>iflt</td><td>判断是否 &lt; 0</td></tr><tr><td>0x9c</td><td>ifge</td><td>判断是否 &gt;&#x3D; 0</td></tr><tr><td>0x9d</td><td>ifgt</td><td>判断是否 &gt; 0</td></tr><tr><td>0x9e</td><td>ifle</td><td>判断是否 &lt;&#x3D; 0</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>两个int是否 &#x3D;&#x3D;</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>两个int是否 !&#x3D;</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>两个int是否 &lt;</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>两个int是否 &gt;&#x3D;</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>两个int是否 &gt;</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>两个int是否 &lt;&#x3D;</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>两个引用是否 &#x3D;&#x3D;</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>两个引用是否 !&#x3D;</td></tr><tr><td>0xc6</td><td>ifnull</td><td>判断是否 &#x3D;&#x3D; null</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>判断是否 !&#x3D; null</td></tr></tbody></table><p>几点说明：</p><ul><li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li><li>goto 用来进行跳转到指定行号的字节码</li></ul><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_3</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;<br><br>      a = <span class="hljs-number">10</span>;<br><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      a = <span class="hljs-number">20</span>;<br><br><br>    &#125;<br><br><br>  &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: iconst_0<br><span class="hljs-attribute">1</span>: istore_1<br><span class="hljs-attribute">2</span>: iload_1<br><span class="hljs-attribute">3</span>: ifne 12<br><span class="hljs-attribute">6</span>: bipush 10<br><span class="hljs-attribute">8</span>: istore_1<br><span class="hljs-attribute">9</span>: goto 15<br><span class="hljs-attribute">12</span>: bipush 20<br><span class="hljs-attribute">14</span>: istore_1<br><span class="hljs-attribute">15</span>: return<br></code></pre></td></tr></table></figure><blockquote><p>以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办？<br>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p></blockquote><h3 id="2-6-循环控制指令"><a href="#2-6-循环控制指令" class="headerlink" title="2.6 循环控制指令"></a>2.6 循环控制指令</h3><p>其实循环控制还是前面介绍的那些指令，例如 while 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_4</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) &#123;<br><br>      a++;<br><br><br>    &#125;<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>字节码是：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: iconst_0<br><span class="hljs-attribute">1</span>: istore_1<br><span class="hljs-attribute">2</span>: iload_1<br><span class="hljs-attribute">3</span>: bipush 10<br><span class="hljs-attribute">5</span>: if_icmpge 14<br><span class="hljs-attribute">8</span>: iinc 1, 1<br><span class="hljs-attribute">11</span>: goto 2<br><span class="hljs-attribute">14</span>: return<br></code></pre></td></tr></table></figure><p>再比如 do while 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_5</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">do</span> &#123;<br><br>      a++;<br><br><br>    &#125; <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>);<br><br><br>  &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>字节码是：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"> <span class="hljs-attribute">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">iconst_0</span><br> <span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">istore_1</span><br><span class="hljs-attribute">2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">iinc 1, 1</span><br> <span class="hljs-attribute">5</span><span class="hljs-punctuation">:</span> <span class="hljs-string">iload_1</span><br><span class="hljs-attribute">6</span><span class="hljs-punctuation">:</span> <span class="hljs-string">bipush 10</span><br><span class="hljs-attribute">8</span><span class="hljs-punctuation">:</span> <span class="hljs-string">if_icmplt 2</span><br><span class="hljs-attribute">11</span><span class="hljs-punctuation">:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>最后再看看 for 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_6</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><br>    <br><br>    &#125;<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>字节码是：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: iconst_0<br><span class="hljs-attribute">1</span>: istore_1<br><span class="hljs-attribute">2</span>: iload_1<br><span class="hljs-attribute">3</span>: bipush 10<br><span class="hljs-attribute">5</span>: if_icmpge 14<br><span class="hljs-attribute">8</span>: iinc 1, 1<br><span class="hljs-attribute">11</span>: goto 2<br><span class="hljs-attribute">14</span>: return<br></code></pre></td></tr></table></figure><blockquote><p>注意<br>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归</p></blockquote><h3 id="2-7-练习-判断结果"><a href="#2-7-练习-判断结果" class="headerlink" title="2.7 练习 - 判断结果"></a>2.7 练习 - 判断结果</h3><p>请从字节码角度分析，下列代码运行的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_6_1</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br><br>      x = x++;<br><br>      i++;<br><br><br>    &#125;<br><br>    System.out.println(x); <span class="hljs-comment">// 结果是 0</span><br><br><br>  &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-8-构造方法"><a href="#2-8-构造方法" class="headerlink" title="2.8 构造方法"></a>2.8 构造方法</h3><h4 id="2-8-1-V"><a href="#2-8-1-V" class="headerlink" title="2.8.1 ( )V"></a>2.8.1 <cinit>( )V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_8_1</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>  <span class="hljs-keyword">static</span> &#123;<br><br>    i = <span class="hljs-number">20</span>;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">static</span> &#123;<br><br>    i = <span class="hljs-number">30</span>;<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方 法 <cinit>()V ：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: bipush 10<br><span class="hljs-attribute">2</span>: putstatic <span class="hljs-comment">#2 // Field i:I</span><br><span class="hljs-attribute">5</span>: bipush 20<br><span class="hljs-attribute">7</span>: putstatic <span class="hljs-comment">#2 // Field i:I</span><br><span class="hljs-attribute">10</span>: bipush 30<br><span class="hljs-attribute">12</span>: putstatic <span class="hljs-comment">#2 // Field i:I</span><br><span class="hljs-attribute">15</span>: return<br></code></pre></td></tr></table></figure><p><cinit>()V 方法会在类加载的初始化阶段被调用</p><blockquote><p>练习<br>可以自己调整一下 static 变量和静态代码块的位置，观察字节码的改动</p></blockquote><h4 id="2-8-2-V"><a href="#2-8-2-V" class="headerlink" title="2.8.2 ( )V"></a>2.8.2 <init>( )V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_8_2</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s1&quot;</span>;<br><br>  &#123;<br><br>    b = <span class="hljs-number">20</span>;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>  &#123;<br><br>    a = <span class="hljs-string">&quot;s2&quot;</span>;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo3_8_2</span><span class="hljs-params">(String a, <span class="hljs-type">int</span> b)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.a = a;<br><br>    <span class="hljs-built_in">this</span>.b = b;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Demo3_8_2</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3_8_2</span>(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br><br>    System.out.println(d.a);<br><br>    System.out.println(d.b);<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构</p><p>造方法内的代码总是在最后</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">cn.itcast.jvm.t3.bytecode.Demo3_8_2(java.lang.String,</span> <span class="hljs-string">int);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">(Ljava/lang/String;I)V</span><br><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC</span><br><br>  <span class="hljs-attr">Code:</span><br><br>  <span class="hljs-string">stack\=2,</span> <span class="hljs-string">locals\=3,</span> <span class="hljs-string">args\_size\=3</span><br><br>    <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br><br>    <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1 // super.&lt;init&gt;()V</span><br><br>    <span class="hljs-attr">4:</span> <span class="hljs-string">aload_0</span><br><br>    <span class="hljs-attr">5:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#2 // &lt;- &quot;s1&quot;</span><br><br>    <span class="hljs-attr">7:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#3 // -&gt; this.a</span><br><br>    <span class="hljs-attr">10:</span> <span class="hljs-string">aload_0</span><br><br>    <span class="hljs-attr">11:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">20</span> <span class="hljs-string">//</span> <span class="hljs-string">&lt;-</span> <span class="hljs-number">20</span><br><br>    <span class="hljs-attr">13:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#4 // -&gt; this.b</span><br><br>    <span class="hljs-attr">16:</span> <span class="hljs-string">aload_0</span><br><br>    <span class="hljs-attr">17:</span> <span class="hljs-string">bipush</span> <span class="hljs-number">10</span> <span class="hljs-string">//</span> <span class="hljs-string">&lt;-</span> <span class="hljs-number">10</span><br><br>    <span class="hljs-attr">19:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#4 // -&gt; this.b</span><br><br>    <span class="hljs-attr">22:</span> <span class="hljs-string">aload_0</span><br><br>    <span class="hljs-attr">23:</span> <span class="hljs-string">ldc</span> <span class="hljs-comment">#5 // &lt;- &quot;s2&quot;</span><br><br>    <span class="hljs-attr">25:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#3 // -&gt; this.a</span><br><br>    <span class="hljs-attr">28:</span> <span class="hljs-string">aload_0</span> <span class="hljs-string">//</span> <span class="hljs-string">------------------------------</span><br><br>    <span class="hljs-attr">29:</span> <span class="hljs-string">aload_1</span> <span class="hljs-string">//</span> <span class="hljs-string">&lt;-</span> <span class="hljs-string">slot</span> <span class="hljs-number">1</span><span class="hljs-string">(a)</span> <span class="hljs-string">&quot;s3&quot;</span> <span class="hljs-string">|</span><br><br>    <span class="hljs-attr">30:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#3 // -&gt; this.a |</span><br><br>    <span class="hljs-attr">33:</span> <span class="hljs-string">aload_0</span> <span class="hljs-string">|</span><br><br>    <span class="hljs-attr">34:</span> <span class="hljs-string">iload_2</span> <span class="hljs-string">//</span> <span class="hljs-string">&lt;-</span> <span class="hljs-string">slot</span> <span class="hljs-number">2</span><span class="hljs-string">(b)</span> <span class="hljs-number">30</span> <span class="hljs-string">|</span><br><br>    <span class="hljs-attr">35:</span> <span class="hljs-string">putfield</span> <span class="hljs-comment">#4 // -&gt; this.b --------------------</span><br><br>    <span class="hljs-attr">38:</span> <span class="hljs-string">return</span><br><br><br>  <span class="hljs-attr">LineNumberTable:</span> <span class="hljs-string">...</span><br><br>  <span class="hljs-attr">LocalVariableTable:</span><br><br>  <span class="hljs-string">Start</span> <span class="hljs-string">Length</span> <span class="hljs-string">Slot</span> <span class="hljs-string">Name</span> <span class="hljs-string">Signature</span><br><br>    <span class="hljs-number">0</span> <span class="hljs-number">39</span> <span class="hljs-number">0</span> <span class="hljs-string">this</span> <span class="hljs-string">Lcn/itcast/jvm/t3/bytecode/Demo3_8_2;</span><br><br>    <span class="hljs-number">0</span> <span class="hljs-number">39</span> <span class="hljs-number">1</span> <span class="hljs-string">a</span> <span class="hljs-string">Ljava/lang/String;</span><br><br>    <span class="hljs-number">0</span> <span class="hljs-number">39</span> <span class="hljs-number">2</span> <span class="hljs-string">b</span> <span class="hljs-string">I</span><br><br><br>  <span class="hljs-attr">MethodParameters:</span> <span class="hljs-string">...</span><br><br><br><br></code></pre></td></tr></table></figure><h3 id="2-9-方法调用"><a href="#2-9-方法调用" class="headerlink" title="2.9 方法调用"></a>2.9 方法调用</h3><p>看一下几种不同的方法调用对应的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_9</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo3_9</span><span class="hljs-params">()</span> &#123; &#125;<br> <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123; &#125;<br> <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123; &#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123; &#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123; &#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">Demo3_9</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3_9</span>();<br>  d.test1();<br>  d.test2();<br>  d.test3();<br>  d.test4();<br>  Demo3_9.test4();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: new <span class="hljs-comment">#2 // class cn/itcast/jvm/t3/bytecode/Demo3_9</span><br><span class="hljs-attribute">3</span>: dup<br><span class="hljs-attribute">4</span>: invokespecial <span class="hljs-comment">#3 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attribute">7</span>: astore_1<br><span class="hljs-attribute">8</span>: aload_1<br><span class="hljs-attribute">9</span>: invokespecial <span class="hljs-comment">#4 // Method test1:()V</span><br><span class="hljs-attribute">12</span>: aload_1<br><span class="hljs-attribute">13</span>: invokespecial <span class="hljs-comment">#5 // Method test2:()V</span><br><span class="hljs-attribute">16</span>: aload_1<br><span class="hljs-attribute">17</span>: invokevirtual <span class="hljs-comment">#6 // Method test3:()V</span><br><span class="hljs-attribute">20</span>: aload_1<br><span class="hljs-attribute">21</span>: pop<br><span class="hljs-attribute">22</span>: invokestatic <span class="hljs-comment">#7 // Method test4:()V</span><br><span class="hljs-attribute">25</span>: invokestatic <span class="hljs-comment">#7 // Method test4:()V</span><br><span class="hljs-attribute">28</span>: return<br></code></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配 合 invokespecial 调用该对象的构造方法 <code>&quot;&lt;init&gt;&quot;:()V</code> （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>最终方法（final），私有方法（private），构造方法都是由 <code>invokespecial</code> 指令来调用，属于<strong>静态绑定</strong></li><li>普通成员方法是由 <code>invokevirtual</code> 调用，属于<strong>动态绑定</strong>，即支持多态</li><li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li><li>比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了</li><li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li></ul><h3 id="2-10-多态的原理"><a href="#2-10-多态的原理" class="headerlink" title="2.10 多态的原理"></a>2.10 多态的原理</h3><p>当执行 invokevirtual 指令时，</p><ol><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际 Class</li><li>Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li><li>查表得到方法的具体地址 5. 执行方法的字节码</li></ol><h3 id="2-11-异常处理"><a href="#2-11-异常处理" class="headerlink" title="2.11 异常处理"></a>2.11 异常处理</h3><p>try-catch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_15_TryCatchTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//多出来一个异常表</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测 2~4 行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 2 号位置（为 e ）</li></ul><p>多个 single-catch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_16_MultipleCatchTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">30</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span><br>       <span class="hljs-number">15</span>: astore_2<br>       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">18</span>: istore_1<br>       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li></ul><p>Finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_17_FinallyTest</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i = <span class="hljs-number">30</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-comment">// try块</span><br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-comment">// try块执行完后，会执行finally    </span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-number">7</span>: istore_1<br>        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">// catch块     </span><br>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">// 异常信息放入局部变量表的2号槽位</span><br>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">14</span>: istore_1<br>       <span class="hljs-comment">// catch块执行完后，会执行finally        </span><br>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">17</span>: istore_1<br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">// 出现异常，但未被 Exception 捕获，会抛出其他异常，这时也需要执行 finally 块中的代码   </span><br>       <span class="hljs-number">21</span>: astore_3<br>       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">24</span>: istore_1<br>       <span class="hljs-number">25</span>: aload_3<br>       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">// 抛出异常</span><br>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any<br>           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any<br></code></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</p><p>注意：虽然从字节码指令看来，每个块中都有 finally 块，但是 finally 块中的代码只会被执行一次</p><p>finally 中的 return</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_18_FinallyReturnTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Code_18_FinallyReturnTest.test();<br>        <span class="hljs-comment">// 结果为 20</span><br>        System.out.println(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i = <span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0<br>        <span class="hljs-number">3</span>: iload_0<br>        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">// 暂存返回值</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0<br>        <span class="hljs-number">8</span>: iload_0<br>        <span class="hljs-number">9</span>: ireturn        <span class="hljs-comment">// ireturn 会返回操作数栈顶的整型值 20</span><br>       <span class="hljs-comment">// 如果出现异常，还是会执行finally 块中的内容，没有抛出异常</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: iload_0<br>       <span class="hljs-number">15</span>: ireturn        <span class="hljs-comment">// 这里没有 athrow 了，也就是如果在 finally 块中如果有返回操作的话，且 try 块中出现异常，会吞掉异常！</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br></code></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：如果在 ﬁnally 中出现了 return，会吞掉异常</li><li>所以不要在finally中进行返回操作</li></ul><p>被吞掉的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//  这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>会发现打印结果为 20 ，并未抛出异常</p><p>finally 不带 return</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br> <span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">return</span> i;<br> &#125; <span class="hljs-keyword">finally</span> &#123;<br>  i = <span class="hljs-number">20</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">// 赋值给i 10</span><br>        <span class="hljs-number">3</span>: iload_0        <span class="hljs-comment">// 加载到操作数栈顶</span><br>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">// 加载到局部变量表的1号位置</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">// 赋值给i 20</span><br>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">// 加载局部变量表1号位置的数10到操作数栈</span><br>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">// 返回操作数栈顶元素 10</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">// 加载异常</span><br>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">// 抛出异常</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br></code></pre></td></tr></table></figure><h3 id="2-12-Synchronized"><a href="#2-12-Synchronized" class="headerlink" title="2.12 Synchronized"></a>2.12 Synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_19_SyncTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Object</span><br>         <span class="hljs-number">3</span>: dup <span class="hljs-comment">// 复制一份栈顶，然后压入栈中。用于函数消耗</span><br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">7</span>: astore_1 <span class="hljs-comment">// 将栈顶的对象地址方法 局部变量表中 1 中</span><br>         <span class="hljs-number">8</span>: aload_1 <span class="hljs-comment">// 加载到操作数栈</span><br>         <span class="hljs-number">9</span>: dup <span class="hljs-comment">// 复制一份，放到操作数栈，用于加锁时消耗</span><br>        <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">// 将操作数栈顶元素弹出，暂存到局部变量表的 2 号槽位。这时操作数栈中有一份对象的引用</span><br>        <span class="hljs-number">11</span>: monitorenter <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-number">12</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">15</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ok</span><br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">20</span>: aload_2 <span class="hljs-comment">// 加载对象到栈顶</span><br>        <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-number">22</span>: goto          <span class="hljs-number">30</span><br>        <span class="hljs-comment">// 异常情况的解决方案 释放锁！</span><br>        <span class="hljs-number">25</span>: astore_3<br>        <span class="hljs-number">26</span>: aload_2<br>        <span class="hljs-number">27</span>: monitorexit<br>        <span class="hljs-number">28</span>: aload_3<br>        <span class="hljs-number">29</span>: athrow<br>        <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 异常表！</span><br>      Exception table:<br>         from    to  target type<br>            <span class="hljs-number">12</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   any<br>            <span class="hljs-number">25</span>    <span class="hljs-number">28</span>    <span class="hljs-number">25</span>   any<br></code></pre></td></tr></table></figure><h2 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h2><p>所谓的 语法糖 ，其实就是指 java 编译器把 .java 源码编译为 .class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h3 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br>   <span class="hljs-comment">// 这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy1</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-built_in">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在 JDK 5 以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 基本类型赋值给包装类型，称为装箱</span><br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-泛型集合取值"><a href="#3-3-泛型集合取值" class="headerlink" title="3.3 泛型集合取值"></a>3.3 泛型集合取值</h3><p>泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy3</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">11</span>: invokestatic  #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-comment">// 这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br>      <span class="hljs-number">14</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">// 这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br>      <span class="hljs-number">22</span>: invokeinterface #<span class="hljs-number">6</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-comment">// 这里进行了类型转换，将 Object 转换成了 Integer</span><br>      <span class="hljs-number">27</span>: checkcast     #<span class="hljs-number">7</span>                  <span class="hljs-comment">// class java/lang/Integer</span><br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>所以调用 get 函数取值时，有一个类型转换的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Integer) list.get(<span class="hljs-number">0</span>); <br></code></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个 int 类型的变量，则还有自动拆箱的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Integer) list.get(<span class="hljs-number">0</span>).intValue(); <br></code></pre></td></tr></table></figure><p>使用反射可以得到，参数的类型以及泛型类型。泛型反射代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>    <span class="hljs-comment">// 1. 拿到方法</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Code_20_ReflectTest.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);<br>    <span class="hljs-comment">// 2. 得到泛型参数的类型信息</span><br>    Type[] types = method.getGenericParameterTypes();<br>    <span class="hljs-keyword">for</span>(Type type : types) &#123;<br>        <span class="hljs-comment">// 3. 判断参数类型是否，带泛型的类型。</span><br>        <span class="hljs-keyword">if</span>(type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) type;<br><br>            <span class="hljs-comment">// 4. 得到原始类型</span><br>            System.out.println(<span class="hljs-string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());<br>            <span class="hljs-comment">// 5. 拿到泛型类型</span><br>            Type[] arguments = parameterizedType.getActualTypeArguments();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title function_">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">原始类型 - <span class="hljs-keyword">interface</span> <span class="hljs-title class_">java</span>.util.List<br>泛型参数[<span class="hljs-number">0</span>] - <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>原始类型 - <span class="hljs-keyword">interface</span> <span class="hljs-title class_">java</span>.util.Map<br>泛型参数[<span class="hljs-number">0</span>] - <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Integer<br>泛型参数[<span class="hljs-number">1</span>] - <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Object<br></code></pre></td></tr></table></figure><h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><p>可变参数也是 JDK 5 开始加入的新特性： 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String... args)</span> &#123;<br>      <span class="hljs-comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br>   <span class="hljs-keyword">public</span> Candy4 &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String[] args)</span> &#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果调用的是 foo() ，即未传递参数时，等价代码为 foo(new String[]{}) ，创建了一个空数组，而不是直接传递的 null .</p><h3 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 foreach 循环</h3><p>仍是 JDK 5 开始引入的语法糖，数组的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 数组赋初值的简化写法也是一种语法糖。</span><br>  <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : arr) &#123;<br>   System.out.println(x);<br>  &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy5</span><span class="hljs-params">()</span> &#123;&#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[i];<br>   System.out.println(x);<br>  &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果是集合使用 foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>集合要使用 foreach ，需要该集合类实现了 Iterable 接口，因为集合的遍历需要用到迭代器 Iterator.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy5</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">// 获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 switch 字符串</h3><p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cnady6</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy6</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy6</span><span class="hljs-params">()</span> &#123;<br>      <br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 通过字符串的 hashCode + value 来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">// hello 的 hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">// 再次比较，因为字符串的 hashCode 有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">// world 的 hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 用第二个 switch 在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的 switch 被分为了两个<ul><li>第一个用来匹配字符串，并给 x 赋值<ul><li>字符串的匹配用到了字符串的 hashCode ，还用到了 equals 方法</li><li>使用 hashCode 是为了提高比较效率，使用 equals 是防止有 hashCode 冲突（如 BM 和 C .）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h3 id="3-7-switch-枚举"><a href="#3-7-switch-枚举" class="headerlink" title="3.7 switch 枚举"></a>3.7 switch 枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy7</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">SEX</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy7</span> &#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$MAP</span> &#123;<br>      <span class="hljs-comment">// 数组大小即为枚举元素个数，里面存放了 case 用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">// ordinal 即枚举元素对应所在的位置，MALE 为 0 ，FEMALE 为 1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">SEX</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> SEX.MALE;<br>      <span class="hljs-comment">// 将对应位置枚举元素的值赋给 x ，用于 case 操作</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-枚举类"><a href="#3-8-枚举类" class="headerlink" title="3.8 枚举类"></a>3.8 枚举类</h3><p>JDK 7 新增了枚举类，以前面的性别枚举为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;Sex&gt; &#123;   <br>   <span class="hljs-comment">// 对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>            <span class="hljs-comment">// 调用构造函数，传入枚举元素的值及 ordinal</span><br>            MALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br>         <br>   <span class="hljs-comment">// 调用父类中的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sex</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> ordinal)</span> &#123;     <br>        <span class="hljs-built_in">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title function_">valueOf</span><span class="hljs-params">(String name)</span> &#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-9-try-with-resources"><a href="#3-9-try-with-resources" class="headerlink" title="3.9 try-with-resources"></a>3.9 try-with-resources</h3><p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象) &#123;<br> <br>&#125; <span class="hljs-keyword">catch</span>() &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-with- resources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy9</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>))&#123; <br>   System.out.println(is); <br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; <br>   e.printStackTrace(); <br>  &#125; <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy9</span> &#123; <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy9</span><span class="hljs-params">()</span> &#123; &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(is); <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123; <br>                <span class="hljs-comment">// t 是我们代码出现的异常 </span><br>                t = e1; <br>                <span class="hljs-keyword">throw</span> e1; <br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 判断了资源不为空 </span><br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-literal">null</span>) &#123; <br>                    <span class="hljs-comment">// 如果我们代码有异常</span><br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123; <br>                        <span class="hljs-keyword">try</span> &#123;<br>                            is.close(); <br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123; <br>                            <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span><br>                            t.addSuppressed(e2); <br>                        &#125; <br>                    &#125; <span class="hljs-keyword">else</span> &#123; <br>                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span><br>                        is.close(); <br>                    &#125; <br>                &#125; <br>            &#125; <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace(); <br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test6</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>  <span class="hljs-keyword">try</span> (<span class="hljs-type">MyResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyResource</span>()) &#123; <br>   <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>; <br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; <br>   e.printStackTrace(); <br>  &#125; <br> &#125; <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;close 异常&quot;</span>); <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero <br> at test.Test6.main(Test6.java:<span class="hljs-number">7</span>) <br> Suppressed: java.lang.Exception: close 异常 <br>  at test.MyResource.close(Test6.java:<span class="hljs-number">18</span>) <br>  at test.Test6.main(Test6.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h3 id="3-10-方法重写时的桥接方法"><a href="#3-10-方法重写时的桥接方法" class="headerlink" title="3.10 方法重写时的桥接方法"></a>3.10 方法重写时的桥接方法</h3><p>我们都知道，方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <br> <span class="hljs-keyword">public</span> Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br> &#125; <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br> <span class="hljs-meta">@Override</span> <br> <span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类  </span><br> <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于子类，java 编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br> <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125;<br> <span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br> <span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>  <span class="hljs-comment">// 调用 public Integer m() </span><br>  <span class="hljs-keyword">return</span> m(); <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以</p><p>用下面反射代码来验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;<br>            System.out.println(m);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer cn.ali.jvm.test.B.m()<br><span class="hljs-keyword">public</span> java.lang.Number cn.ali.jvm.test.B.m()<br></code></pre></td></tr></table></figure><h3 id="3-10-匿名内部类"><a href="#3-10-匿名内部类" class="headerlink" title="3.10 匿名内部类"></a>3.10 匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy10</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy10</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 用额外创建的类来创建匿名内部类对象</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Candy10$1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建了一个额外的类，实现了 Runnable 接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy10$1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引用局部变量的匿名内部类，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy11</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x)</span> &#123; <br>  <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>   <span class="hljs-meta">@Override</span> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + x); <br>   &#125; <br>  &#125;; <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>转换后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类 </span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy11$1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123; <br> <span class="hljs-type">int</span> val$x; <br> Candy11$<span class="hljs-number">1</span>(<span class="hljs-type">int</span> x) &#123; <br>  <span class="hljs-built_in">this</span>.val$x = x; <br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>  System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-built_in">this</span>.val$x); <br> &#125; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy11</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x)</span> &#123; <br>  <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Candy11$1</span>(x); <br> &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 final 的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 值后，如果不是 final 声明的 x 值发生了改变，匿名内部类则值不一致。</p><h2 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><ul><li><p>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，先加载父类</p></li><li><p>加载和链接可能是交替运行的</p></li></ul><p>如果这个类还有父类没有加载，先加载父类</p><p>加载和链接可能是交替运行的</p><p><img src="http://images.changzer.cn/image_1.92148459.png"></p><ul><li>instanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在堆内存中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><p><strong>注意</strong></p><ul><li>instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中</li><li>可以通过前面介绍的 HSDB 工具查看</li></ul><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><h4 id="4-2-1-验证"><a href="#4-2-1-验证" class="headerlink" title="4.2.1 验证"></a>4.2.1 验证</h4><p>验证类是否符合 JVM规范，安全性检查</p><p>用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行</p><h4 id="4-2-2-准备"><a href="#4-2-2-准备" class="headerlink" title="4.2.2 准备"></a>4.2.2 准备</h4><p>为 static 变量分配空间，设置默认值</p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_22_AnalysisTest</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Code_22_AnalysisTest.class.getClassLoader();<br>        Class&lt;?&gt; c = classLoader.loadClass(<span class="hljs-string">&quot;cn.ali.jvm.test.C&quot;</span>);<br><br>        <span class="hljs-comment">// new C();</span><br>        System.in.read();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3初始化"><a href="#4-3初始化" class="headerlink" title="4.3初始化"></a>4.3初始化</h3><p><strong><cinit>()v 方法</strong></p><p>初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全</p><p><strong>发生的时机</strong></p><p>概括得说，类初始化是【懒惰的】</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load1</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 1. 静态常量（基本类型和字符串）不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(B.b);</span><br>        <span class="hljs-comment">// 2. 类对象.class 不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(B.class);</span><br>        <span class="hljs-comment">// 3. 创建该类的数组不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(new B[0]);</span><br>        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span><br><span class="hljs-comment">//         ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="hljs-comment">//         cl.loadClass(&quot;cn.ali.jvm.test.classload.B&quot;);</span><br>        <span class="hljs-comment">// 5. 不会初始化类 B，但会加载 B、A</span><br><span class="hljs-comment">//         ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span><br><span class="hljs-comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;, false, c2);</span><br><br><br>        <span class="hljs-comment">// 1. 首次访问这个类的静态变量或静态方法时</span><br><span class="hljs-comment">//         System.out.println(A.a);</span><br>        <span class="hljs-comment">// 2. 子类初始化，如果父类还没初始化，会引发</span><br><span class="hljs-comment">//         System.out.println(B.c);</span><br>        <span class="hljs-comment">// 3. 子类访问父类静态变量，只触发父类初始化</span><br><span class="hljs-comment">//         System.out.println(B.a);</span><br>        <span class="hljs-comment">// 4. 会初始化类 B，并先初始化类 A</span><br><span class="hljs-comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;);</span><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5.0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h3><p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(E.a);<br>        System.out.println(E.b);<br>        <span class="hljs-comment">// 会导致 E 类初始化，因为 Integer 是包装类</span><br>        System.out.println(E.c);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;E cinit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>典型应用 - 完成懒惰初始化单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125; <br>    <span class="hljs-comment">// 内部类中保存单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyHolder</span> &#123; <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <br>    &#125;<br>    <span class="hljs-comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ul><h2 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等！</p><p>以JDK 8为例</p><table><thead><tr><th>名称,</th><th>加载的类,</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h3 id="5-1-启动类的加载器"><a href="#5-1-启动类的加载器" class="headerlink" title="5.1 启动类的加载器"></a>5.1 启动类的加载器</h3><p>可通过在控制台输入指令，使得类被启动类加器加载</p><p>用 Bootstrap 类加载器加载类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> <br>&#123; <br>  <span class="hljs-keyword">static</span> &#123; <br><br>    System.out.println(<span class="hljs-string">&quot;bootstrap F init&quot;</span>); <br><br><br>  &#125; <br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load5_1</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.F&quot;</span>);<br><br>    System.out.println(aClass.getClassLoader());<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:.<br>cn.itcast.jvm.t3.load.Load5<br>bootstrap F init<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><ul><li>-Xbootclasspath 表示设置 bootclasspath</li><li>其中 &#x2F;a:. 表示将当前目录追加至 bootclasspath 之后</li><li>可以用这个办法替换核心类<ul><li>java -Xbootclasspath: <new bootclasspath></li><li>java -Xbootclasspath&#x2F;a:&lt;追加路径&gt;</li><li>java -Xbootclasspath&#x2F;p:&lt;追加路径&gt;</li></ul></li></ul><h3 id="5-2-扩展类的加载器"><a href="#5-2-扩展类的加载器" class="headerlink" title="5.2 扩展类的加载器"></a>5.2 扩展类的加载器</h3><p>如果 classpath 和 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p><p><strong>使用应用程序类加载器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> &#123;<br>  <span class="hljs-keyword">static</span> &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;classpath G init&quot;</span>);<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load5_2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.G&quot;</span>);<br><br>    System.out.println(aClass.getClassLoader());<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">classpath G init <br>sun.misc.Launcher$AppClassLoader@18b4aac2 <br></code></pre></td></tr></table></figure><p><strong>使用扩展类加载器</strong></p><p>写一个同名的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span> &#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;ext G init&quot;</span>);<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>打个 jar 包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class<br>已添加清单<br>正在添加: cn/itcast/jvm/t3/load/G.class(输入 = <span class="hljs-number">481</span>) (输出 = <span class="hljs-number">322</span>)(压缩了 <span class="hljs-number">33</span>%)<br></code></pre></td></tr></table></figure><p>将 jar 包拷贝到 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p><p>重新执行 Load5_2</p><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ext G init <br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则。</p><blockquote><p>注意 这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p></blockquote><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">// 如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">// 然后让应用类加载器去找 classpath 下找该类</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Load5_3</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>    Class&lt;?&gt; aClass = Load5_3.class.getClassLoader()<br><br>    .loadClass(<span class="hljs-string">&quot;cn.itcast.jvm.t3.load.H&quot;</span>);<br><br>    System.out.println(aClass.getClassLoader());<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程为：</p><ol><li>sun.misc.Launcher$AppClassLoader &#x2F;&#x2F;1 处， 开始查看已加载的类，结果没有</li><li><code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F; 2 处，委派上级 sun.misc.Launcher$ExtClassLoader.loadClass()</li><li>sun.misc.Launcher$ExtClassLoader &#x2F;&#x2F; 1 处，查看已加载的类，结果没有</li><li>sun.misc.Launcher$ExtClassLoader &#x2F;&#x2F; 3 处，没有上级了，则委派 BootstrapClassLoader 查找</li><li>BootstrapClassLoader 是在 JAVA_HOME&#x2F;jre&#x2F;lib 下找 H 这个类，显然没有</li><li><code>sun.misc.Launcher$ExtClassLoader</code>    &#x2F;&#x2F; 4 处，调用自己的 findClass 方法，是在 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader 的 &#x2F;&#x2F; 2 处</li><li>继续执行到 sun.misc.Launcher$AppClassLoader &#x2F;&#x2F; 4 处，调用它自己的 findClass 方法，在 classpath 下查找，找到了</li></ol><h3 id="5-4-自定义类加载器"><a href="#5-4-自定义类加载器" class="headerlink" title="5.4 自定义类加载器"></a>5.4 自定义类加载器</h3><p><strong>使用场景</strong></p><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><p><strong>步骤</strong></p><ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法</li><li>不是重写 loadClass 方法，否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e:\\myclasspath\\&quot;</span> + name + <span class="hljs-string">&quot;.class&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            Files.copy(Paths.get(path), os);<br><br>            <span class="hljs-comment">// 得到字节数组</span><br>            <span class="hljs-type">byte</span>[] bytes = os.toByteArray();<br><br>            <span class="hljs-comment">// byte[] -&gt; *.class</span><br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;类文件未找到&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>破坏双亲委派模式</strong></p><ul><li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代</p><ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的</p><ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的</p><ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h2 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><h4 id="6-1-1-分层编译"><a href="#6-1-1-分层编译" class="headerlink" title="6.1.1 分层编译"></a>6.1.1 分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 即时编译器编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><blockquote><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p></blockquote><p>即时编译器（JIT）与解释器的区别</p><ul><li><p>解释器</p><ul><li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li><p>即时编译器</p><ul><li>将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。</p><p><strong>逃逸分析</strong></p><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p>对象逃逸状态</p><p>全局逃逸（GlobalEscape）</p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p>参数逃逸（ArgEscape）</p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p>没有逃逸</p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><p>开启锁消除：-XX:+EliminateLocks</p><p>关闭锁消除：-XX:-EliminateLocks</p><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><p>开启标量替换：-XX:+EliminateAllocations</p><p>关闭标量替换：-XX:-EliminateAllocations</p><p>显示标量替换详情：-XX:+PrintEliminateAllocations</p><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="6-1-2-方法内联"><a href="#6-1-2-方法内联" class="headerlink" title="6.1.2 方法内联"></a>6.1.2 方法内联</h4><p><strong>内联函数</strong></p><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> i)</span> &#123;<br>  <span class="hljs-keyword">return</span> i * i;<br><br><br>&#125;<br><br>System.out.println(square(<span class="hljs-number">9</span>)); <br></code></pre></td></tr></table></figure><p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、</p><p>粘贴到调用者的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);  <br></code></pre></td></tr></table></figure><p>还能够进行常量折叠（constant folding）的优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">81</span>); <br></code></pre></td></tr></table></figure><h4 id="6-1-3-字段优化"><a href="#6-1-3-字段优化" class="headerlink" title="6.1.3 字段优化"></a>6.1.3 字段优化</h4><p>JMH 基准测试请参考：<a href="http://openjdk.java.net/projects/code-tools/jmh/">http://openjdk.java.net/projects/code-tools/jmh/</a></p><p>创建 maven 工程，添加依赖如下</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jmh.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jmh.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>编写基准测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadLocalRandom;<br><br><span class="hljs-comment">//进行几轮热身</span><br><span class="hljs-meta">@Warmup(iterations = 2, time = 1)</span><br><span class="hljs-comment">//进行几轮测试</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@State(Scope.Benchmark)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Benchmark1</span> &#123;<br> <span class="hljs-type">int</span>[] elements = randomInts(<span class="hljs-number">1_000</span>);<br> <br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] randomInts(<span class="hljs-type">int</span> size) &#123;<br>  <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br>  <span class="hljs-type">int</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>   values[i] = random.nextInt();<br>  &#125;<br>  <span class="hljs-keyword">return</span> values;<br> &#125;<br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123;<br>   doSum(elements[i]);<br>  &#125;<br> &#125;<br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span>[] local = <span class="hljs-built_in">this</span>.elements;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; local.length; i++) &#123;<br>   doSum(local[i]);<br>  &#125;<br> &#125;<br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : elements) &#123;<br>  doSum(element);<br>  &#125;<br> &#125;<br> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-meta">@CompilerControl(CompilerControl.Mode.INLINE)</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  sum += x;<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>  <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>  .include(Benchmark1.class.getSimpleName())<br>  .forks(<span class="hljs-number">1</span>)<br>  .build();<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>首先启用 doSum 的方法内联，测试结果如下（每秒吞吐量，分数越高的更好）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units<br><span class="hljs-attribute">t</span>.Benchmark1.test1 thrpt <span class="hljs-number">5</span> <span class="hljs-number">2420286</span>.<span class="hljs-number">539</span> <span class="hljs-number">390747</span>.<span class="hljs-number">467</span> ops/s<br><span class="hljs-attribute">t</span>.Benchmark1.test2 thrpt <span class="hljs-number">5</span> <span class="hljs-number">2544313</span>.<span class="hljs-number">594</span> <span class="hljs-number">91304</span>.<span class="hljs-number">136</span> ops/s<br><span class="hljs-attribute">t</span>.Benchmark1.test3 thrpt <span class="hljs-number">5</span> <span class="hljs-number">2469176</span>.<span class="hljs-number">697</span> <span class="hljs-number">450570</span>.<span class="hljs-number">647</span> ops/s<br></code></pre></td></tr></table></figure><p>接下来禁用 doSum 方法内联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  sum += x;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span> Mode Samples Score Score error Units<br><span class="hljs-attribute">t</span>.Benchmark1.test1 thrpt <span class="hljs-number">5</span> <span class="hljs-number">296141</span>.<span class="hljs-number">478</span> <span class="hljs-number">63649</span>.<span class="hljs-number">220</span> ops/s<br><span class="hljs-attribute">t</span>.Benchmark1.test2 thrpt <span class="hljs-number">5</span> <span class="hljs-number">371262</span>.<span class="hljs-number">351</span> <span class="hljs-number">83890</span>.<span class="hljs-number">984</span> ops/s<br><span class="hljs-attribute">t</span>.Benchmark1.test3 thrpt <span class="hljs-number">5</span> <span class="hljs-number">368960</span>.<span class="hljs-number">847</span> <span class="hljs-number">60163</span>.<span class="hljs-number">391</span> ops/s<br></code></pre></td></tr></table></figure><p>分析：</p><p>在刚才的示例中，doSum 方法是否内联会影响 elements 成员变量读取的优化：</p><p>如果 doSum 方法内联了，刚才的 test1 方法会被优化成下面的样子（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Benchmark</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; elements.length; i++) &#123; <span class="hljs-comment">// 后续 999 次 求长度 &lt;- local</span><br><br>    sum += elements[i]; <span class="hljs-comment">// 1000 次取下标 i 的元素 &lt;- local</span><br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以节省 1999 次 Field 读取操作</p><p>但如果 doSum 方法没有内联，则不会进行上面的优化</p><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.reflect;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflect1</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> Reflect1.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">16</span>; i++) &#123;<br><br>      System.out.printf(<span class="hljs-string">&quot;%d\t&quot;</span>, i);<br><br>      foo.invoke(<span class="hljs-literal">null</span>);<br><br><br>    &#125;<br><br>    System.in.read();<br><br><br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sun.reflect;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> sun.reflect.misc.ReflectUtil;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br><br>  <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numInvocations;<br><br>  <br><br>  NativeMethodAccessorImpl(Method method) &#123;<br><br>    <span class="hljs-built_in">this</span>.method = method;<br><br><br>  &#125;<br><br>  <br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object target, Object[] args)</span><br><br>  <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException &#123;<br><br>    <span class="hljs-comment">// inflationThreshold 膨胀阈值，默认 15</span><br><br>    <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold()<br><br>    &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-built_in">this</span>.method.getDeclaringClass()))<br><br>    &#123;<br><br>      <span class="hljs-comment">// 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快 20 倍左右</span><br><br>      <span class="hljs-type">MethodAccessorImpl</span> <span class="hljs-variable">generatedMethodAccessor</span> <span class="hljs-operator">=</span><br><br>        (MethodAccessorImpl)<br><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>())<br><br>          .generateMethod(<br><br>            <span class="hljs-built_in">this</span>.method.getDeclaringClass(),<br><br>            <span class="hljs-built_in">this</span>.method.getName(),<br><br>            <span class="hljs-built_in">this</span>.method.getParameterTypes(),<br><br>            <span class="hljs-built_in">this</span>.method.getReturnType(),<br><br>            <span class="hljs-built_in">this</span>.method.getExceptionTypes(),<br><br>            <span class="hljs-built_in">this</span>.method.getModifiers()<br><br><br>          );<br><br><br><br>      <span class="hljs-built_in">this</span>.parent.setDelegate(generatedMethodAccessor);<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 调用本地实现</span><br><br>    <span class="hljs-keyword">return</span> invoke0(<span class="hljs-built_in">this</span>.method, target, args);<br><br><br>  &#125;<br><br>  <br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl parent)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.parent = parent;<br><br><br>  &#125;<br><br>  <br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">invoke0</span><span class="hljs-params">(Method method, Object target, Object\[\] args)</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>当调用到第 16 次（从0开始算）时，会采用运行时生成的类代替掉最初的实现，可以通过 debug 得到</p><p>类名为 sun.reflect.GeneratedMethodAccessor1</p><p>可以使用阿里的 arthas 工具：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>arthas-<span class="hljs-keyword">boot.jar</span><br><span class="hljs-keyword"></span>[INFO] arthas-<span class="hljs-keyword">boot </span>version: <span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br>[INFO] Found existing <span class="hljs-keyword">java </span>process, please choose one <span class="hljs-keyword">and </span>hit RETURN.<br>* [<span class="hljs-number">1</span>]: <span class="hljs-number">13065</span> cn.itcast.<span class="hljs-keyword">jvm.t3.reflect.Reflect1</span><br></code></pre></td></tr></table></figure><p>选择 1 回车表示分析该进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br>[INFO] arthas home: /root/.arthas/lib/<span class="hljs-number">3.1</span><span class="hljs-number">.1</span>/arthas<br>[INFO] Try to attach process <span class="hljs-number">13065</span><br>[INFO] Attach process <span class="hljs-number">13065</span> success.<br>[INFO] arthas-client connect <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">3658</span><br>,---. ,------. ,--------.,--. ,--. ,---. ,---.<br>/ O \ | .--. <span class="hljs-string">&#x27;&#x27;</span>--. .--<span class="hljs-string">&#x27;| &#x27;</span>--<span class="hljs-string">&#x27; | / O \ &#x27;</span> .-<span class="hljs-string">&#x27;</span><br><span class="hljs-string">| .-. || &#x27;</span>--<span class="hljs-string">&#x27;.&#x27;</span> | | | .--. || .-. |`. `-.<br>| | | || |\ \ | | | | | || | | |.-<span class="hljs-string">&#x27; |</span><br><span class="hljs-string">`--&#x27;</span> `--<span class="hljs-string">&#x27;`--&#x27;</span> <span class="hljs-string">&#x27;--&#x27;</span> `--<span class="hljs-string">&#x27; `--&#x27;</span> `--<span class="hljs-string">&#x27;`--&#x27;</span> `--<span class="hljs-string">&#x27;`-----&#x27;</span><br>wiki https:<span class="hljs-comment">//alibaba.github.io/arthas</span><br>tutorials https:<span class="hljs-comment">//alibaba.github.io/arthas/arthas-tutorials</span><br>version <span class="hljs-number">3.1</span><span class="hljs-number">.1</span><br>pid <span class="hljs-number">13065</span><br>time <span class="hljs-number">2019</span>-<span class="hljs-number">06</span>-<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">23</span>:<span class="hljs-number">54</span><br></code></pre></td></tr></table></figure><p>再输入【jad + 类名】来进行反编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">$ jad sun.reflect.GeneratedMethodAccessor1<br>ClassLoader:<br>+-sun.reflect.DelegatingClassLoader@15db9742<br>+-sun.misc.Launcher$AppClassLoader@4e0e2f2a<br>+-sun.misc.Launcher$ExtClassLoader@2fdb006e<br>Location:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Decompiled with CFR 0_132.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Could not load the following classes:</span><br><span class="hljs-comment">* cn.itcast.jvm.t3.reflect.Reflect1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">package</span> sun.reflect;<br><span class="hljs-keyword">import</span> cn.itcast.jvm.t3.reflect.Reflect1;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> sun.reflect.MethodAccessorImpl;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratedMethodAccessor1</span><br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  * Loose catch block</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  * Enabled aggressive block sorting</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  * Enabled unnecessary exception pruning</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  * Enabled aggressive exception aggregation</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  * Lifted jumps to return sites</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object object, Object[] arrobject)</span> <span class="hljs-keyword">throws</span><br><br>  InvocationTargetException &#123;<br><br>    <span class="hljs-comment">// 比较奇葩的做法，如果有参数，那么抛非法参数异常</span><br><br>    block4 : &#123;<br><br>      <span class="hljs-keyword">if</span> (arrobject == <span class="hljs-literal">null</span> || arrobject.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> block4;<br><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br><br>      <span class="hljs-comment">// 可以看到，已经是直接调用了😱😱😱</span><br><br>      Reflect1.foo();<br><br>      <span class="hljs-comment">// 因为没有返回值</span><br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationTargetException</span>(throwable);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;<br><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(Object.<span class="hljs-built_in">super</span>.toString());<br><br><br>    &#125;<br><br><br>  &#125;<br><br><br>&#125;<br>Affect(row-cnt:<span class="hljs-number">1</span>) cost in <span class="hljs-number">1540</span> ms.<br></code></pre></td></tr></table></figure><blockquote><p>注意<br>通过查看 ReflectionFactory 源码可知</p><ul><li>sun.reflect.noInflation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）</li><li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习java虚拟机——（2）垃圾回收</title>
    <link href="/2022/09/14/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%942%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/09/14/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%942%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1、任何判断对象可以回收"><a href="#1、任何判断对象可以回收" class="headerlink" title="1、任何判断对象可以回收"></a>1、任何判断对象可以回收</h2><h3 id="1-1引用计数法"><a href="#1-1引用计数法" class="headerlink" title="1.1引用计数法"></a>1.1引用计数法</h3><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="http://images.changzer.cn/image_1.4389efff.png"></p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p><em>首先需要确定一系列</em><em><strong>根对象</strong></em><em>(肯定不能被当成垃圾被回收的对象)，在垃圾回收之前，会对堆内存中的所有对象进行一遍扫描，判断每一个对象是否是被根对象所</em><em><strong>直接或者间接</strong></em><em>的引用，如果是这个对象就不能被回收，反之如果一个对象没有被根对象直接或者间接的引用，那么这个对象就可以直接被作为垃圾，将来可以被回收。</em></p><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p><ul><li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，<strong>找不到，表示可以 回收</strong></li><li>哪些对象可以作为 GC Root ?<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-number">1</span>);<br>        System.in.read();<br><br>        list = <span class="hljs-literal">null</span>;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于以上代码，可以使用如下命令将堆内存信息转储成一个文件，然后使用Eclipse Memory Analyzer 工具进行分析。</p><p>第一步：</p><p>使用 jps 命令，查看程序的进程</p><p><img src="http://images.changzer.cn/image_2.e000f846.png"></p><p>第二步：</p><p><img src="http://images.changzer.cn/image_3.313b6276.png"></p><p>使用 jmap -dump:format&#x3D;b,live,file&#x3D;1.bin 16104 命令转储文件</p><p>dump：转储文件</p><p>format&#x3D;b：二进制文件</p><p>file：文件名</p><p>16104：进程的id</p><p>第三步：打开 Eclipse Memory Analyzer (MAT) 对 1.bin 文件进行分析。</p><p><img src="http://images.changzer.cn/image_4.8b50421b.png"></p><p>分析的 gc root，找到了 ArrayList 对象，然后将 list 置为null，再次转储，那么 list 对象就会被回收。</p><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="http://images.changzer.cn/image_5.162fcdd5.png"></p><ol><li>强引用</li></ol><p>只有所有 GC Roots 对象都<strong>不通过【强引用】引用该对象，该对象才能被垃圾回收</strong></p><ol start="2"><li>软引用（SoftReference）</li></ol><p>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时会再次出发垃圾回收</strong>，回收软引用对象</p><p>可以配合引用队列来释放软引用自身</p><ol start="3"><li>弱引用（WeakReference）</li></ol><p>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足，都会回收弱引用对象</strong></p><p>可以配合引用队列来释放弱引用自身</p><ol start="4"><li>虚引用（PhantomReference）</li></ol><p><strong>必须配合引用队列使用</strong>，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法(unsafe类方法)释放直接内存</p><ol start="5"><li>终结器引用（FinalReference）</li></ol><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由** Finalizer 线程**通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p><h4 id="1-3-1-example01-软引用"><a href="#1-3-1-example01-软引用" class="headerlink" title="1.3.1 example01: 软引用"></a>1.3.1 example01: 软引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_08_SoftReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        method2();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 -Xmx20m , 演示堆内存不足,</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ArrayList&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 软引用</span><br><span class="hljs-comment">// List -&gt; SoftReference -&gt; byte[]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p><p><img src="http://images.changzer.cn/image_6.1e2b1251.png"></p><p>上面的代码中，当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用。</p><p>修改 method2 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示 软引用 搭配引用队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>(poll != <span class="hljs-literal">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="http://images.changzer.cn/image_7.cdb33433.png"></p><h4 id="1-3-2-example02-弱引用"><a href="#1-3-2-example02-弱引用" class="headerlink" title="1.3.2 example02: 弱引用"></a>1.3.2 example02: 弱引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_09_WeakReferenceTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        method1();</span><br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> *<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// 演示 弱引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        List&lt;WeakReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB]);<br>            list.add(weakReference);<br><br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 弱引用搭配 引用队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        List&lt;WeakReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>            list.add(weakReference);<br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===========================================&quot;</span>);<br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll != <span class="hljs-literal">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; wake : list) &#123;<br>            System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://images.changzer.cn/image_8.c259594a.png"></p><h2 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><p>定义：Mark Sweep</p><ul><li>速度较快</li><li>会产生内存碎片</li></ul><p><img src="http://images.changzer.cn/image_1.591a1661.png"></p><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><p>定义: Mark Compact</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><img src="http://images.changzer.cn/image_2.295d0a87.png"></p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>定义: Copy</p><ul><li>不会有内存碎片</li><li>需要占用两倍内存空间</li></ul><p><img src="http://images.changzer.cn/image_3.0d8dde89.png"></p><h3 id="2-4-分代垃圾回收"><a href="#2-4-分代垃圾回收" class="headerlink" title="2.4 分代垃圾回收"></a>2.4 分代垃圾回收</h3><p><img src="http://images.changzer.cn/image_4.c2c65e54.png"></p><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发  ​<code>Minor GC​</code>，伊甸园和  ​<code>from</code>​  存活的对象使用  ​<em>copy算法</em>​  复制到  ​<code>to</code>​  中，存活的对象年龄加 1并且交换 <code>from</code> 和<code>to</code></li><li><code>Minor GC</code> 会引发 <code>stop the world</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，<strong>最大寿命是15（4bit）</strong></li><li>当老年代空间不足，会先尝试触发 <code>Minor GC</code>，如果之后空间仍不足，那么触发 <code>Full GC </code>，STW的时间更长</li></ul><h2 id="3、分代垃圾回收"><a href="#3、分代垃圾回收" class="headerlink" title="3、分代垃圾回收"></a>3、分代垃圾回收</h2><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数"></a>3.1 相关 VM 参数</h3><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>Xmx 或 -XX:MaxHeapSize&#x3D;size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio&#x3D;ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold&#x3D;threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h3 id="3-2-GC分析"><a href="#3-2-GC分析" class="headerlink" title="3.2 GC分析"></a>3.2 GC分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_10_GC</span> Test &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_512KB</span> <span class="hljs-operator">=</span> <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_6MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_7MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_8MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_6MB]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 Minor GC，什么时候触发 Full GC 等情况，使用前需要设置 jvm 参数。</p><h2 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h2><p>相关概念</p><ul><li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上</li><li>吞吐量：即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</li></ul><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h3><ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul><blockquote><p>-XX:+UseSerialGC&#x3D;serial + serialOld</p></blockquote><p><img src="http://images.changzer.cn/image_1.40cfe6e2.png"></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p><ol><li><strong>Serial 收集器</strong></li></ol><p>Serial 收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p><p>ParNew 收集器</p><ol start="2"><li><strong>ParNew 收集器</strong></li></ol><p>ParNew 收集器其实就是 Serial 收集器的多线程版本</p><p><strong>特点：</strong>多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGC Threads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p><p>Serial Old 收集器</p><ol start="3"><li><strong>Serial Old 收集器</strong></li></ol><p>Serial Old 是 Serial 收集器的老年代版本</p><p><strong>特点：</strong>同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><ul><li>多线程</li><li>堆内存较大，多核CUP</li><li>让单位时间内S, TW的时间最短</li><li>JDK1.8默认使用的垃圾回收器</li></ul><p><img src="http://images.changzer.cn/image_2.ef6e2c9a.png"></p><ol><li><strong>Parallel Scavenge 收集器</strong></li></ol><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点：</strong>属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略：</strong>Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h3><ul><li>多线程</li><li>堆内存较大，多核CUP</li><li>尽可能让单次STW的时间变短</li></ul><blockquote><p>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ Serialold<br>-XX:ParallelGC Threads&#x3D;n &#x2F;&#x2F;并行线程数 ~ -XX:ConcGCThreads&#x3D;threads &#x2F;&#x2F;并发线程数<br>-XX:CMSInitiatingOccupancyFraction&#x3D;percent &#x2F;&#x2F;执行垃圾回收时的内存占比<br>-XX:+CMSScavengeBeforeRemark</p></blockquote><p><img src="http://images.changzer.cn/image_3.1c6f6306.png"></p><p>CMS 收集器</p><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p><p>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p><p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p><p>CMS 收集器的运行过程分为下列4步：</p><ol><li>初始标记：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</li><li>并发标记：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</li><li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题</li><li>并发清除：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li></ol><p>CMS 收集器的内存回收过程是与用户线程一起并发执行的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。</p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h3><p>定义： Garbage First</p><p>适用场景：</p><ul><li>同时注重吞吐量和低延迟（响应时间），默认的暂停目标是 200 ms</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li>整体上是<code>标记-整理算法</code>，两个区域之间是<code>复制算法</code></li></ul><p>相关参数：</p><p>JDK8 并不是默认开启的，所需要参数开启</p><blockquote><p>-XX:+UseG1GC<br>-XX:G1HeapRegionSize&#x3D;size<br>-XX:MaxGCPauseMillis&#x3D;time</p></blockquote><h4 id="4-4-1-G1-垃圾回收阶段"><a href="#4-4-1-G1-垃圾回收阶段" class="headerlink" title="4.4.1 G1 垃圾回收阶段"></a>4.4.1 G1 垃圾回收阶段</h4><h5 id="1-Young-Collection"><a href="#1-Young-Collection" class="headerlink" title="1) Young Collection"></a>1) Young Collection</h5><ul><li>会STW</li></ul><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！</p><p><img src="http://images.changzer.cn/image_4.088a0b36.png"></p><p>伊甸园</p><p><img src="http://images.changzer.cn/image_5.7a5544c8.png"></p><p><img src="http://images.changzer.cn/image_6.ba69bba3.png"></p><p>幸存区</p><p><img src="http://images.changzer.cn/image_7.d84c9741.png"></p><p><img src="http://images.changzer.cn/image_8.a37df897.png"></p><p>老年代</p><p><img src="http://images.changzer.cn/image_9.f488fcb4.png"></p><h5 id="2-Young-Collection-CM"><a href="#2-Young-Collection-CM" class="headerlink" title="2) Young Collection + CM"></a>2) Young Collection + CM</h5><ul><li>在 Young GC 时会进行 GC Root 的初始标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</li></ul><blockquote><p>-XX:InitiatingHeapOccupancyPercent&#x3D;percent （默认45%）</p></blockquote><p><img src="http://images.changzer.cn/image_10.a133d13d.png"></p><h5 id="3-Mixed-Collection"><a href="#3-Mixed-Collection" class="headerlink" title="3) Mixed Collection"></a>3) Mixed Collection</h5><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记（Remark）会 STW</li><li>拷贝存活（Evacuation）会 STW</li></ul><blockquote><p>-XX:MaxGCPauseMillis&#x3D;ms</p></blockquote><p>为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</p><p><img src="http://images.changzer.cn/image_11.35398cc4.png"></p><h4 id="4-4-2-Full-GC"><a href="#4-4-2-Full-GC" class="headerlink" title="4.4.2 Full GC"></a>4.4.2 Full GC</h4><p>SerialGC</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul><p>ParallelGC</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul><p>CMS</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足 (在并发失败的时候CMS会退化为 -full gc)</li></ul><p>G1</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发 Full GC，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。</li></ul></li></ul><h4 id="4-4-3-Young-Collection-跨代引用"><a href="#4-4-3-Young-Collection-跨代引用" class="headerlink" title="4.4.3 Young Collection 跨代引用"></a>4.4.3 Young Collection 跨代引用</h4><p>新生代回收的跨代引用（老年代引用新生代）问题</p><p><img src="http://images.changzer.cn/image_12.9f4a3e98.png"></p><ul><li><p>卡表 与 Remembered Set</p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O 被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过 post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads 更新 Remembered Set</p></li><li><p><img src="http://images.changzer.cn/image_13.1b84eb9e.png"></p></li></ul><h4 id="4-4-4-Remark"><a href="#4-4-4-Remark" class="headerlink" title="4.4.4 Remark"></a>4.4.4 Remark</h4><p>pre-write barrier + satb_mark_queue</p><p>黑色：已被处理，需要保留的</p><p>灰色：正在处理中的</p><p>白色：还未处理的</p><p><img src="http://images.changzer.cn/image_14.9ccb617a.png"></p><p>但是在并发标记过程中，有可能 A 被处理了以后未引用 C ，但该处理过程还未结束，在处理过程结束之前 A 引用了 C ，这时就会用到 remark 。</p><p>过程如下</p><ul><li>之前 C 未被引用，这时 A 引用了 C ，就会给 C 加一个写屏障，写屏障的指令会被执行，将 C 放入一个队列当中，并将 C 变为 处理中状态</li><li>在并发标记阶段结束以后，重新标记阶段会 STW ，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它，由灰色变成黑色。</li></ul><p><img src="http://images.changzer.cn/image_15.de847b5a.png"></p><p><img src="http://images.changzer.cn/image_16.3de788c4.png"></p><h4 id="4-4-5-JDK-8u20-字符串去重"><a href="#4-4-5-JDK-8u20-字符串去重" class="headerlink" title="4.4.5 JDK 8u20 字符串去重"></a>4.4.5 JDK 8u20 字符串去重</h4><p>优点：节省大量内存</p><p>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</p><blockquote><p>-XX:+UseStringDeduplication</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复</li><li>如果它们值一样，让它们引用同一个 char[]</li><li>String.intern() 关注的是字符串对象<ul><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><h4 id="4-4-6-JDK-8u40-并发标记类卸载"><a href="#4-4-6-JDK-8u40-并发标记类卸载" class="headerlink" title="4.4.6 JDK 8u40 并发标记类卸载"></a>4.4.6 JDK 8u40 并发标记类卸载</h4><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><blockquote><p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p></blockquote><h4 id="4-4-7-JDK-8u60-回收巨型对象"><a href="#4-4-7-JDK-8u60-回收巨型对象" class="headerlink" title="4.4.7 JDK 8u60 回收巨型对象"></a>4.4.7 JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="http://images.changzer.cn/image_17.3fdf333c.png"></p><h4 id="4-4-8-JDK-9-并发标记起始时间的调整"><a href="#4-4-8-JDK-9-并发标记起始时间的调整" class="headerlink" title="4.4.8 JDK 9 并发标记起始时间的调整"></a>4.4.8 JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成，否则退化为 FulGC</li><li>JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code></li><li><code> \-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值<ul><li><code>\-XX:InitiatingHeapOccupancyPercent</code> 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h2 id="5、垃圾回收调优"><a href="#5、垃圾回收调优" class="headerlink" title="5、垃圾回收调优"></a>5、垃圾回收调优</h2><p>查看虚拟机参数命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">java  -XX:+PrintFlagsFinal -version <span class="hljs-string">| findstr &quot;</span>GC<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>Io</li><li>gc</li></ul><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><p>低延迟&#x2F;高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC"></a>5.3 最快的 GC</h3><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看 Full GC 前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？<ul><li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小 16 Integer 24 int 4</li></ul></li><li>是否存在内存泄漏<ul><li>static Map map …</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h3><ul><li><p>新生代的特点</p><ul><li>所有的 new 操作分配内存都是非常廉价的<ul><li>TLAB thread-lcoal allocation buffer</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>Minor GC 所用时间远小于 Full GC</li></ul></li><li><p>新生代内存越大越好么？</p><ul><li>不是<ul><li>新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li><li><p>幸存区需要能够保存 当前活跃对象+需要晋升的对象</p></li><li><p>晋升阈值配置得当，让长时间存活的对象尽快晋升</p></li></ul><blockquote><p>-XX:MaxTenuringThreshold&#x3D;threshold<br>-XX:+PrintTenuringDistrubution</p></blockquote><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优"></a>5.5 老年代调优</h3><p>以 CMS 为例：</p><ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经，否者先尝试调优新生代。</li><li>观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li></ul><blockquote><p>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习java虚拟机——（1）内存结构</title>
    <link href="/2022/09/08/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%941%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2022/09/08/%E5%AD%A6%E4%B9%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%941%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="学习java虚拟机——（1）内存结构"><a href="#学习java虚拟机——（1）内存结构" class="headerlink" title="学习java虚拟机——（1）内存结构"></a>学习java虚拟机——（1）内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><h3 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><h3 id="1-2作用"><a href="#1-2作用" class="headerlink" title="1.2作用"></a>1.2作用</h3><p>记住下一条jvm指令的执行地址</p><img src="http://images.changzer.cn/image_1.7ba7c63b.png" alt="" referrerpolicy="no-referrer"><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><p><img src="http://images.changzer.cn/image_2.bf70bc52.png"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>每个线程运行时所需要的内存，称为虚拟机栈</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="http://images.changzer.cn/image_1.23f6946a.png"></p><p>问题辨析</p><ol><li>垃圾回收是否涉及栈内存？</li></ol><p><strong>不需要</strong>&#x3D;&#x3D;。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。垃圾回收&#x3D;&#x3D;只会回收堆内存，不会回收栈内存。</p><ol start="2"><li>栈内存分配越大越好吗？</li></ol><p>&#x3D;&#x3D;不是。因为&#x3D;&#x3D;<strong>物理内存是一定的</strong>&#x3D;&#x3D;，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。&#x3D;&#x3D;</p><ol start="3"><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的<br>如果方法内<strong>局部变量没有逃离方法的作用访问</strong>，它是线程安全的</li></ol><p>  如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p><h3 id="2-2-内存溢出"><a href="#2-2-内存溢出" class="headerlink" title="2.2 内存溢出"></a>2.2 内存溢出</h3><ul><li>栈帧过多导致栈内存溢出(无限递归)</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><ol><li>CPU占用过高</li></ol><ul><li>&#x3D;&#x3D;Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程&#x3D;&#x3D;<ul><li><code>top</code>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><code>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</code> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><code>jstack 进程id</code> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制</strong>的，需要<strong>转换</strong></li></ul></li></ul><ol start="2"><li>运行很长时间没有结果</li></ol><p>可能由于多个线程发生死锁，<code>jstack 进程id</code> 通过查看进程中的线程的nid</p><p><img src="http://images.changzer.cn/image_2.c173bcf4.png"></p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>一些带有<strong>native</strong>关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>通过<strong>new关键字创建的对象</strong>都会被放在堆内存</p><p><strong>特点</strong></p><ul><li>所有线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><p>**java.lang.OutofMemoryError **：java heap space. 堆内存溢出</p><p><strong>堆内存诊断</strong></p><ol><li><strong>jps</strong> : 查看当前系统中有哪些 java 进程*(获得进程id)* <code>jps</code></li><li><strong>jmap</strong> (某时刻) 查看堆内存占用情况 <code>jmap -heap 进程id</code></li><li>**jconsole **图形化界面的，多功能的监测工具，可以连续监测 <code>jconsole</code></li><li>**jvisualvm **<code>jvisualvm</code></li></ol><p><img src="http://images.changzer.cn/image_1.dd8e7f68.png"></p><p><img src="http://images.changzer.cn/image_2.ff1d470a.png"></p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>方法区是在所有 Java 虚拟机线程之间<strong>共享</strong>。它<strong>存储每个类的结构</strong>，如<strong>运行时常量池</strong>、<strong>字段</strong>和<strong>方法数据</strong>，以及<strong>方法</strong>和<strong>构造函数</strong>的代码，包括类和实例初始化以及接口初始化中使用的特殊方法 。</p><p>&#x3D;&#x3D;方法区域是在虚拟机启动时创建的。&#x3D;&#x3D;尽管方法区域在&#x3D;&#x3D;逻辑上是堆的一部分&#x3D;&#x3D;，但简单的实现可能会选择不进行垃圾回收或压缩它。此规范不规定方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，也可以根据计算的要求进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的。</p><p>  <strong>如果方法区域中的内存无法用于满足分配请求，则 Java 虚拟机将引发 .OutOfMemoryError</strong></p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>StringTable后来放在堆里的原因是永久栈的垃圾回收效率不高, 在堆中只需触发minGc就可进行回收</p><p><img src="http://images.changzer.cn/image_1.a92e0dd5.png"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h3><ul><li>1.8以前会导致永久代内存溢出</li><li>1.8以后会导致元空间内存溢出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123; <span class="hljs-comment">// 可以用来加载类的二进制字节码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Demo1_8</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1_8</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++, j++) &#123;<br>                <span class="hljs-comment">// ClassWriter 作用是生成类的二进制字节码</span><br>                <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 版本号， public， 类名, 包名, 父类， 接口</span><br>                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-comment">// 返回 byte[]</span><br>                <span class="hljs-type">byte</span>[] code = cw.toByteArray();<br>                <span class="hljs-comment">// 执行了类的加载</span><br>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length); <span class="hljs-comment">// Class 对象</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-常量池"><a href="#5-4-常量池" class="headerlink" title="5.4 常量池"></a>5.4 常量池</h3><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li>在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入</li><li>在控制台输入 javap -v 类的绝对路径</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs sh">E:\jvm\out\production\jvm\cn\itcast\jvm\t5&gt;javap -v HelloWorld.class<br>Classfile /E:/jvm/out/production/jvm/cn/itcast/jvm/t5/HelloWorld.class<br>//类基本信息<br>  Last modified 2022-9-5; size 567 bytes<br>  MD5 checksum 8efebdac91aa496515fa1c161184e354<br>  Compiled from <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br>public class cn.itcast.jvm.t5.HelloWorld<br>  minor version: 0<br>  major version: 52<br>  flags: ACC_PUBLIC, ACC_SUPER<br><br>//常量池<br>**Constant pool:**<br>   <span class="hljs-comment">#1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-comment">#3 = String             #23            // hello world</span><br>   <span class="hljs-comment">#4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   <span class="hljs-comment">#5 = Class              #26            // cn/itcast/jvm/t5/HelloWorld</span><br>   <span class="hljs-comment">#6 = Class              #27            // java/lang/Object</span><br>   <span class="hljs-comment">#7 = Utf8               &lt;init&gt;</span><br>   <span class="hljs-comment">#8 = Utf8               ()V</span><br>   <span class="hljs-comment">#9 = Utf8               Code</span><br>  <span class="hljs-comment">#10 = Utf8               LineNumberTable</span><br>  <span class="hljs-comment">#11 = Utf8               LocalVariableTable</span><br>  <span class="hljs-comment">#12 = Utf8               this</span><br>  <span class="hljs-comment">#13 = Utf8               Lcn/itcast/jvm/t5/HelloWorld;</span><br>  <span class="hljs-comment">#14 = Utf8               main</span><br>  <span class="hljs-comment">#15 = Utf8               ([Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#16 = Utf8               args</span><br>  <span class="hljs-comment">#17 = Utf8               [Ljava/lang/String;</span><br>  <span class="hljs-comment">#18 = Utf8               SourceFile</span><br>  <span class="hljs-comment">#19 = Utf8               HelloWorld.java</span><br>  <span class="hljs-comment">#20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-comment">#21 = Class              #28            // java/lang/System</span><br>  <span class="hljs-comment">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#23 = Utf8               hello world</span><br>  <span class="hljs-comment">#24 = Class              #31            // java/io/PrintStream</span><br>  <span class="hljs-comment">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#26 = Utf8               cn/itcast/jvm/t5/HelloWorld</span><br>  <span class="hljs-comment">#27 = Utf8               java/lang/Object</span><br>  <span class="hljs-comment">#28 = Utf8               java/lang/System</span><br>  <span class="hljs-comment">#29 = Utf8               out</span><br>  <span class="hljs-comment">#30 = Utf8               Ljava/io/PrintStream;</span><br>  <span class="hljs-comment">#31 = Utf8               java/io/PrintStream</span><br>  <span class="hljs-comment">#32 = Utf8               println</span><br>  <span class="hljs-comment">#33 = Utf8               (Ljava/lang/String;)V</span><br><br>//类的方法定义<br>&#123;<br>public cn.itcast.jvm.t5.HelloWorld(); //构造方法<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=1, locals=1, args_size=1<br>         0: aload_0<br>         1: invokespecial <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         4: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 4: 0<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       5     0  this   Lcn/itcast/jvm/t5/HelloWorld;<br><br>public static void main(java.lang.String[]); //main方法<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=1, args_size=1<br>//虚拟机指令<br>         0: getstatic     <span class="hljs-comment">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         3: ldc           <span class="hljs-comment">#3                  // String hello world</span><br>         5: invokevirtual <span class="hljs-comment">#4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         8: <span class="hljs-built_in">return</span><br>      LineNumberTable:<br>        line 6: 0<br>        line 7: 8<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  args   [Ljava/lang/String;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;HelloWorld.java&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><p><strong>常量池：</strong>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p><p><strong>运行时常量池：</strong>常量池是.class文件中的，当该*类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的<strong>符号地址</strong>变为<strong>真实地址</strong></p><h3 id="5-5-StringTable-的特性"><a href="#5-5-StringTable-的特性" class="headerlink" title="5.5 StringTable 的特性"></a>5.5 StringTable 的特性</h3><ul><li><p>常量池中的字符串仅是符号，<strong>只有在被用到时才会转化为对象</strong></p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量拼接</strong>的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量拼接</strong>的原理是<strong>编译器优化</strong></p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p><ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入！如果没有则放入串池，会把串池中的对象返回</li></ul></li><li><p>注意：无论是串池还是堆里面的字符串，都是对象</p></li></ul><h4 id="5-5-1-用来放字符串对象且里面的元素不重复"><a href="#5-5-1-用来放字符串对象且里面的元素不重复" class="headerlink" title="5.5.1 用来放字符串对象且里面的元素不重复"></a>5.5.1 用来放字符串对象且里面的元素不重复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，还没有成为java字符串</p><blockquote><p>0: ldc #2 &#x2F;&#x2F; String a<br>2: astore_1<br>3: ldc #3 &#x2F;&#x2F; String b<br>5: astore_2<br>6: ldc #4 &#x2F;&#x2F; String ab<br>8: astore_3<br>9: return</p></blockquote><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，并放入串池中（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意：</strong>字符串对象的创建都是<strong>懒惰</strong>的，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><h4 id="5-5-2-使用拼接字符串变量对象创建字符串的过程"><a href="#5-5-2-使用拼接字符串变量对象创建字符串的过程" class="headerlink" title="5.5.2 使用拼接字符串变量对象创建字符串的过程"></a>5.5.2 使用拼接字符串变量对象创建字符串的过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2; <span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() -&gt; new String(&quot;ab&quot;)</span><br>        System.out.println(s3 == s4);   <span class="hljs-comment">//false</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><blockquote><p>Code:<br>stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1<br>0: ldc #2 &#x2F;&#x2F; String a<br>2: astore_1<br>3: ldc #3 &#x2F;&#x2F; String b<br>5: astore_2<br>6: ldc #4 &#x2F;&#x2F; String ab<br>8: astore_3<br>9: new #5 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder<br>12: dup<br>13: invokespecial #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.”<init>“:()V<br>16: aload_1<br>17: invokevirtual #7 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;<br>20: aload_2<br>21: invokevirtual #7 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;<br>24: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str<br>ing;<br>27: astore 4<br>29: return</p></blockquote><p>通过拼接的方式来创建字符串的过程是：<strong>StringBuilder().append(“a”).append(“b”).toString()</strong></p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的值和拼接的字符串一致，但是两个不同的字符串，一个存在于<strong>串池</strong>之中，一个存在于<strong>堆内存</strong>之中.</p><h4 id="5-5-3-使用拼接字符串常量对象的方法创建字符串"><a href="#5-5-3-使用拼接字符串常量对象的方法创建字符串" class="headerlink" title="5.5.3 使用拼接字符串常量对象的方法创建字符串"></a>5.5.3 使用拼接字符串常量对象的方法创建字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2; <span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span><br><br>        System.out.println(s3 == s5);     <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><blockquote><p>&#x3D;&#x3D;Code:&#x3D;&#x3D;<br>&#x3D;&#x3D;stack&#x3D;2, locals&#x3D;6, args_size&#x3D;1&#x3D;&#x3D;<br>&#x3D;&#x3D;0: ldc #2 &#x2F;&#x2F; String a&#x3D;&#x3D;<br>&#x3D;&#x3D;2: astore_1&#x3D;&#x3D;<br>&#x3D;&#x3D;3: ldc #3 &#x2F;&#x2F; String b&#x3D;&#x3D;<br>&#x3D;&#x3D;5: astore_2&#x3D;&#x3D;<br>&#x3D;&#x3D;6: ldc #4 &#x2F;&#x2F; String ab&#x3D;&#x3D;<br>&#x3D;&#x3D;8: astore_3&#x3D;&#x3D;<br>&#x3D;&#x3D;9: new #5 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder&#x3D;&#x3D;<br>&#x3D;&#x3D;12: dup&#x3D;&#x3D;<br>&#x3D;&#x3D;13: invokespecial #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.”<init>“:()V&#x3D;&#x3D;<br>&#x3D;&#x3D;16: aload_1&#x3D;&#x3D;<br>&#x3D;&#x3D;17: invokevirtual #7 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String&#x3D;&#x3D;<br>&#x3D;&#x3D;;)Ljava&#x2F;lang&#x2F;StringBuilder;&#x3D;&#x3D;<br>&#x3D;&#x3D;20: aload_2&#x3D;&#x3D;<br>&#x3D;&#x3D;21: invokevirtual #7 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String&#x3D;&#x3D;<br>&#x3D;&#x3D;;)Ljava&#x2F;lang&#x2F;StringBuilder;&#x3D;&#x3D;<br>&#x3D;&#x3D;24: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str&#x3D;&#x3D;<br>&#x3D;&#x3D;ing;&#x3D;&#x3D;<br>&#x3D;&#x3D;27: astore 4&#x3D;&#x3D;<br>&#x3D;&#x3D;&#x2F;&#x2F;ab3初始化时直接从串池中获取字符串&#x3D;&#x3D;<br>&#x3D;&#x3D;29: ldc #4 &#x2F;&#x2F; String ab&#x3D;&#x3D;<br>&#x3D;&#x3D;31: astore 5&#x3D;&#x3D;<br>&#x3D;&#x3D;33: return&#x3D;&#x3D;</p></blockquote><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化</strong>，<strong>结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，<strong>只能在运行期确定它的值</strong>，<strong>所以需要使用StringBuilder来创建</strong></li></ul><h4 id="5-5-4-intern方法-1-8"><a href="#5-5-4-intern方法-1-8" class="headerlink" title="5.5.4 intern方法 1.8"></a>5.5.4 intern方法 1.8</h4><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p>注意：此时如果调用intern方法<strong>成功，堆内存与串池中的字符串对象是同一个对象</strong>；如果<strong>失败，则不是同一个对象</strong></p><ul><li>成功:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>  <span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br>  <span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>  <span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>  System.out.println(str == st2);<br>  System.out.println(str == str3);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>失败:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>        <span class="hljs-comment">//false</span><br>  System.out.println(str == str2);<br>        <span class="hljs-comment">//false</span><br>  System.out.println(str == str3);<br>        <span class="hljs-comment">//true</span><br>  System.out.println(str2 == str3);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-5-intern方法-1-6"><a href="#5-5-5-intern方法-1-6" class="headerlink" title="5.5.5 intern方法 1.6"></a>5.5.5 intern方法 1.6</h4><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会<strong>返回串池中</strong>的字符串对象</p><p><strong>注意：</strong>此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象</p><h3 id="5-6-StringTable-垃圾回收"><a href="#5-6-StringTable-垃圾回收" class="headerlink" title="5.6 StringTable 垃圾回收"></a>5.6 StringTable 垃圾回收</h3><p>StringTable在内存紧张时，会发生垃圾回收</p><h3 id="5-7-StringTable-调优"><a href="#5-7-StringTable-调优" class="headerlink" title="5.7 StringTable 调优"></a>5.7 StringTable 调优</h3><ul><li>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</li></ul><blockquote><p>-XX:StringTableSize&#x3D;xxxx</p></blockquote><ul><li>考虑是否需要将字符串对象入池, 可以通过<code>intern</code>方法减少重复入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><ul><li>属于操作系统，常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><p><strong>文件读写流程</strong></p><p><img src="http://images.changzer.cn/image_1.54c7464b.png"></p><p><strong>使用了DirectBuffer</strong></p><p><img src="http://images.changzer.cn/image_2.f9cad261.png"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><p><strong>释放原理</strong></p><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<code>unsafe.freeMemory</code>来手动释放</p><p>通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存 </span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>DirectByteBuffer类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-type">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> VM.isDirectMemoryPageAligned();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> Bits.pageSize();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-type">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-built_in">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-built_in">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                   <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-literal">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure><p>对应对象的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>直接内存的回收机制总结</strong></p><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要<strong>主动调用<code>freeMemory</code>方法</strong></li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-XX:+DisableExplicitGC 显式的<br></code></pre></td></tr></table></figure><p>禁用显式的垃圾回收(代码中的<code>System.gc()</code>)，可能会影响字节内存的释放回收</p>]]></content>
    
    
    <categories>
      
      <category>学习java虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC接收页面表单参数</title>
    <link href="/2021/08/19/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SpringMVC%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0/"/>
    <url>/2021/08/19/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SpringMVC%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>   几个简单的Spring mvc页面表单提交获取数据后台接收参数实现</p><p>   转：<a href="http://www.cnblogs.com/luxh/archive/2013/03/14/2960152.html">http://www.cnblogs.com/luxh/archive/2013/03/14/2960152.html</a></p><span id="more"></span><h2 id="1、直接把表单的参数写在Controller相应的方法的形参中"><a href="#1、直接把表单的参数写在Controller相应的方法的形参中" class="headerlink" title="1、直接把表单的参数写在Controller相应的方法的形参中"></a>1、直接把表单的参数写在Controller相应的方法的形参中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RequestMapping(&quot;/addUser1&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser1</span><span class="hljs-params">(String userName,String password)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;userName is:&quot;</span>+userName);<br>        System.out.println(<span class="hljs-string">&quot;password is:&quot;</span>+password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/user/success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2、通过HttpServletRequest接收"><a href="#2、通过HttpServletRequest接收" class="headerlink" title="2、通过HttpServletRequest接收"></a>2、通过HttpServletRequest接收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RequestMapping(&quot;/addUser2&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser2</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;userName&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;userName is:&quot;</span>+userName);<br>        System.out.println(<span class="hljs-string">&quot;password is:&quot;</span>+password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/user/success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3、通过一个bean来接收"><a href="#3、通过一个bean来接收" class="headerlink" title="3、通过一个bean来接收"></a>3、通过一个bean来接收</h2><h4 id="1）建立一个和表单中参数对应的bean"><a href="#1）建立一个和表单中参数对应的bean" class="headerlink" title="1）建立一个和表单中参数对应的bean"></a>1）建立一个和表单中参数对应的bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String userName;<br>    <br>    <span class="hljs-keyword">private</span> String password;<br> <br>    <span class="hljs-comment">//省略了get和set方法也可以用@Data</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）用这个bean来封装接收的参数"><a href="#2）用这个bean来封装接收的参数" class="headerlink" title="2）用这个bean来封装接收的参数"></a>2）用这个bean来封装接收的参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><br><span class="hljs-meta">@RequestMapping(&quot;/addUser3&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser3</span><span class="hljs-params">(User user)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;userName is:&quot;</span>+user.getUserName());<br>        System.out.println(<span class="hljs-string">&quot;password is:&quot;</span>+user.getPassword());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/user/success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4、通过json数据接收"><a href="#4、通过json数据接收" class="headerlink" title="4、通过json数据接收"></a>4、通过json数据接收</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br>&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;<br>&lt;title&gt;Add User&lt;/title&gt;<br> <br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/resource/script/jquery-1.9.1.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(document).ready(function()<span class="hljs-punctuation">&#123;</span><br>        $(<span class="hljs-string">&quot;#button_submit&quot;</span>).click(function()<span class="hljs-punctuation">&#123;</span><br>            var name = $(<span class="hljs-string">&quot;#userName&quot;</span>).val();<br>            var pass = $(<span class="hljs-string">&quot;#password&quot;</span>).val();<br>            <br> <br>            var user = <span class="hljs-punctuation">&#123;</span>userName<span class="hljs-punctuation">:</span>name<span class="hljs-punctuation">,</span>password<span class="hljs-punctuation">:</span>pass<span class="hljs-punctuation">&#125;</span>;<span class="hljs-comment">//拼装成json格式</span><br>            <br>            $.ajax(<span class="hljs-punctuation">&#123;</span><br>                type<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>                url<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/addUser4&quot;</span><span class="hljs-punctuation">,</span><br>                data<span class="hljs-punctuation">:</span>user<span class="hljs-punctuation">,</span><br>                success<span class="hljs-punctuation">:</span>function(data)<span class="hljs-punctuation">&#123;</span><br>                    alert(<span class="hljs-string">&quot;成功&quot;</span>);<br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                error<span class="hljs-punctuation">:</span>function(e) <span class="hljs-punctuation">&#123;</span><br>                    alert(<span class="hljs-string">&quot;出错：&quot;</span>+e);<br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span>);<br>        <span class="hljs-punctuation">&#125;</span>);<br>    <span class="hljs-punctuation">&#125;</span>);<br>&lt;/script&gt;<br> <br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form&gt;<br>        &lt;table&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt;账号&lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;userName&quot;</span> name=<span class="hljs-string">&quot;userName&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt;密码&lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;password&quot;</span> id=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt; &lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;button&quot;</span> id=<span class="hljs-string">&quot;button_submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>        &lt;/table&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="依然可以使用bean来接收json数据"><a href="#依然可以使用bean来接收json数据" class="headerlink" title="依然可以使用bean来接收json数据"></a>依然可以使用bean来接收json数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RequestMapping(&quot;/addUser4&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser4</span><span class="hljs-params">(User user)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;userName is:&quot;</span>+user.getUserName());<br>        System.out.println(<span class="hljs-string">&quot;password is:&quot;</span>+user.getPassword());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/user/success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5、使用jQuery的serializeArray-方法序列化表单元素"><a href="#5、使用jQuery的serializeArray-方法序列化表单元素" class="headerlink" title="5、使用jQuery的serializeArray() 方法序列化表单元素"></a>5、使用jQuery的serializeArray() 方法序列化表单元素</h2><pre><code class="hljs">        如果表单元素很多，手工拼装成json数据非常麻烦，可以使用jQuery提供的serializeArray()方法序列化表单元素，返回json数据结构数据。</code></pre><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br>&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;<br>&lt;title&gt;Add User&lt;/title&gt;<br> <br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/resource/script/jquery-1.9.1.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>    $(document).ready(function()<span class="hljs-punctuation">&#123;</span><br>        $(<span class="hljs-string">&quot;#button_submit&quot;</span>).click(function()<span class="hljs-punctuation">&#123;</span><br>            <br>            <span class="hljs-comment">//序列化表单元素，返回json数据</span><br>            var params = $(<span class="hljs-string">&quot;#userForm&quot;</span>).serializeArray();<br>            <br>            <span class="hljs-comment">//也可以把表单之外的元素按照name value的格式存进来</span><br>            <span class="hljs-comment">//params.push(&#123;name:&quot;hello&quot;,value:&quot;man&quot;&#125;);</span><br>            <br>            $.ajax(<span class="hljs-punctuation">&#123;</span><br>                type<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>                url<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/user/addUser5&quot;</span><span class="hljs-punctuation">,</span><br>                data<span class="hljs-punctuation">:</span>params<span class="hljs-punctuation">,</span><br>                success<span class="hljs-punctuation">:</span>function(data)<span class="hljs-punctuation">&#123;</span><br>                    alert(<span class="hljs-string">&quot;成功&quot;</span>);<br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                error<span class="hljs-punctuation">:</span>function(e) <span class="hljs-punctuation">&#123;</span><br>                    alert(<span class="hljs-string">&quot;出错：&quot;</span>+e);<br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span>);<br>        <span class="hljs-punctuation">&#125;</span>);<br>    <span class="hljs-punctuation">&#125;</span>);<br>&lt;/script&gt;<br> <br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form id=<span class="hljs-string">&quot;userForm&quot;</span>&gt;<br>        &lt;table&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt;账号&lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;userName&quot;</span> name=<span class="hljs-string">&quot;userName&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt;密码&lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;password&quot;</span> id=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>            &lt;tr&gt;<br>                &lt;td&gt; &lt;/td&gt;<br>                &lt;td&gt;<br>                    &lt;input type=<span class="hljs-string">&quot;button&quot;</span> id=<span class="hljs-string">&quot;button_submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>                &lt;/td&gt;<br>            &lt;/tr&gt;<br>        &lt;/table&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="依然可以使用bean来接收json数据："><a href="#依然可以使用bean来接收json数据：" class="headerlink" title="依然可以使用bean来接收json数据："></a>依然可以使用bean来接收json数据：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/addUser5&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addUser5</span><span class="hljs-params">(User user)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;userName is:&quot;</span>+user.getUserName());<br>        System.out.println(<span class="hljs-string">&quot;password is:&quot;</span>+user.getPassword());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/user/success&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/08/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/08/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="字符描述："><a href="#字符描述：" class="headerlink" title="字符描述："></a>字符描述：</h1><ul><li><p>\：将下一个字符标记为特殊字符或字面值。例如 “n “与字符 “n “匹配。 “\n “与换行符匹配。序列 “\ “与 “\ “匹配， “( “与 “( “匹配。</p><span id="more"></span></li><li><p>^ ：匹配输入的开始位置。</p></li><li><p>$ ：匹配输入的结尾。</p></li><li><p>* ：匹配前一个字符零次或几次。例如， “zo* “可以匹配 “z “、 “zoo “。</p></li><li><p>+ ：匹配前一个字符一次或多次。例如， “zo+ “可以匹配 “zoo “,但不匹配 “z “。</p></li><li><p>? ：匹配前一个字符零次或一次。例如， “a?ve? “可以匹配 “never “中的 “ve “。</p></li><li><p>.：匹配换行符以外的任何字符。</p></li><li><p>(pattern) 与模式匹配并记住匹配。匹配的子字符串可以从作为结果的 Matches 集合中使用 Item [0]…[n]取得。如果要匹配括号字符(和 )，可使用 “( “ 或 “) “。</p></li><li><p>x|y：匹配 x 或 y。例如 “z|food “ 可匹配 “z “ 或 “food “。 “(z|f)ood “ 匹配 “zoo “ 或 “food “。</p></li><li><p>{n}：n 为非负的整数。匹配恰好n次。例如， “o{2} “ 不能与 “Bob 中的 “o “ 匹配，但是可以与 “foooood “中的前两个o匹配。</p></li><li><p>{n,} ：n 为非负的整数。匹配至少n次。例如， “o{2,} “不匹配 “Bob “中的 “o “，但是匹配 “foooood “中所有的o。 “o{1,} “等价于 “o+ “。 “o{0,} “等价于 “o* “。</p></li><li><p>{n,m} ：m 和 n 为非负的整数。匹配至少 n 次，至多 m 次。例如， “o{1,3} “ 匹配 “fooooood “中前三个o。 “o{0,1} “等价于 “o? “。</p></li><li><p>[xyz] ：一个字符集。与括号中字符的其中之一匹配。例如， “[abc] “ 匹配 “plain “中的 “a “。</p></li><li><p>[^xyz] ：一个否定的字符集。匹配不在此括号中的任何字符。例如， “[^abc] “ 可以匹配 “plain “中的 “p “.</p></li><li><p>[a-z] ：表示某个范围内的字符。与指定区间内的任何字符匹配。例如， “[a-z] “匹配 “a “与 “z “之间的任何一个小写字母字符。</p></li><li><p>[^m-z] ：否定的字符区间。与不在指定区间内的字符匹配。例如， “[m-z] “与不在 “m “到 “z “之间的任何字符匹配。</p></li><li><p>\b ：与单词的边界匹配，即单词与空格之间的位置。例如， “er\b “ 与 “never “中的 “er “匹配，但是不匹配 “verb “中的 “er “。</p></li><li><p>\B ：与非单词边界匹配。 “ea*r\B “与 “never early “中的 “ear “匹配。</p></li><li><p>\d ：与一个数字字符匹配。等价于[0-9]。</p></li><li><p>\D ：与非数字的字符匹配。等价于【^0-9】。</p></li><li><p>\f ：与分页符匹配。</p></li><li><p>\n ：与换行符字符匹配。</p></li><li><p>\r ：与回车字符匹配。</p></li><li><p>\s ：与任何白字符匹配，包括空格、制表符、分页符等。等价于 “[ \f\n\r\t\v] “。</p></li><li><p>\S ：与任何非空白的字符匹配。等价于 “【^ \f\n\r\t\v】 “。</p></li><li><p>\t ：与制表符匹配。</p></li><li><p>\v ：与垂直制表符匹配。</p></li><li><p>\w ：与任何单词字符匹配，包括下划线。等价于 “[A-Za-z0-9_] “。</p></li><li><p>\W ：与任何非单词字符匹配。等价于 ”【^A-Za-z0-9_】 “。</p></li><li><p>\num ：匹配 num个，其中 num 为一个正整数。引用回到记住的匹配。例如， “(.)\1 “匹配两个连续的相同的字符。</p></li><li><p>\n：匹配 n，其中n 是一个八进制换码值。八进制换码值必须是 1, 2 或 3 个数字长。<br>例如， “\11 “ 和 “\011 “ 都与一个制表符匹配。 “\0011 “等价于 “\001 “ 与 “1 “。八进制换码值不得超过 256。否则，只有前两个字符被视为表达式的一部分。允许在正则表达式中使用ASCII码。</p></li><li><p>\xn：匹配n，其中n是一个十六进制的换码值。十六进制换码值必须恰好为两个数字长。例如， “\x41 “匹配 “A “。 “\x041 “等价于 “\x04 “ 和 “1 “。允许在正则表达式中使用 ASCII 码。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Servlet/"/>
    <url>/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Servlet/</url>
    
    <content type="html"><![CDATA[<p>这里是学习Servlet时的一些笔记整理</p><span id="more"></span><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="HttpServletRequest对象"><a href="#HttpServletRequest对象" class="headerlink" title="HttpServletRequest对象"></a>HttpServletRequest对象</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>获取客服端发出请求时的完整URL</td></tr><tr><td>getRequestURI()</td><td>获取请求行中的资源名称部分（项目名称开始）</td></tr><tr><td>getQueryString()</td><td>获取请求行中的参数部分</td></tr><tr><td>getMethod()</td><td>获取客服端请求方式</td></tr><tr><td>getProtocol()</td><td>获取HTTP版本号</td></tr><tr><td>getContextPath()</td><td>获取webapp名字(&#x2F;+当前项目的名字)</td></tr><tr><td>getParameter()</td><td>获取指定名称参数,返回字符串（重点）</td></tr><tr><td>getParameterValues()</td><td>获取指定名称参数,返回字符串组</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取完整路径</span><br>StringBuffer URL=request.getRequestURL();<br>System.out.println(<span class="hljs-string">&quot;URL: &quot;</span> + URL);<br><span class="hljs-comment">//获取请求时的部分路径</span><br>String URI=request.getRequestURI();<br>System.out.println(<span class="hljs-string">&quot;URI: &quot;</span> + URI);<br><span class="hljs-comment">//获取请求时的参数字符串</span><br>String queryString=request.getQueryString();<br>System.out.println(<span class="hljs-string">&quot;queryString: &quot;</span> + queryString);<br><span class="hljs-comment">//获取请求方式（GET和POST）</span><br>String method=request.getMethod();<br>System.out.println(<span class="hljs-string">&quot;method: &quot;</span> + method);<br><span class="hljs-comment">//获取当前协议版本（HTTP/1.1）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span>request.getProtocol();<br>System.out.println(<span class="hljs-string">&quot;protocol: &quot;</span>+protocol);<br><span class="hljs-comment">//获取项目站点名</span><br>String webapp=request.getContextPath();<br>System.out.println(<span class="hljs-string">&quot;webapp: &quot;</span>+webapp);<br><br><span class="hljs-comment">//获取指定名称参数,返回字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;name: &quot;</span> +name+<span class="hljs-string">&quot; pwd: &quot;</span>+pwd);<br><span class="hljs-comment">//获取指定名称参数,返回字符串组</span><br>String[] hobbys = request.getParameterValues(<span class="hljs-string">&quot;hobby&quot;</span>);<br><span class="hljs-comment">//判断是否为空</span><br><span class="hljs-keyword">if</span>(hobbys!=<span class="hljs-literal">null</span>&amp;&amp;hobbys.length!=<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">for</span>(String hobby: hobbys)&#123;<br>         System.out.println(<span class="hljs-string">&quot;爱好: &quot;</span>+hobby);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h3><p>tomcat 8以上版本：</p><p>​GET请求：不会乱码</p><p>​POST请求：会乱码用 <code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p><p>tomacat 7以下版本：</p><p>​POST请求：会乱码用 <code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>   &#x2F;&#x2F;只对7的post有效</p><p>​GET请求：会乱码      用<code>new String (request.getParameter(&quot;name&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8“) </code>  &#x2F;&#x2F;而8以上不乱码使用后乱码</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (request.getParameter(<span class="hljs-string">&quot;name&quot;</span>).getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>1.一种服务器行为，2.地址栏URL地址不变，3.从始至终只有一个请求发出，4.数据共享（后台跳前台）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.getRequestDispatcher(url).forward(request,response);<br></code></pre></td></tr></table></figure><h3 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h3><p>通过该对象可以在一次请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效.</p><p>可以在请求转发中使用，一个设置另一个获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置域对象内容</span><br>request.setAttrivute(String name,Object value);<br><span class="hljs-comment">//获取域对象内容</span><br>request.getAttribut(String name);<br><span class="hljs-comment">//删除域对象内容</span><br>request.removeAttribute(String name);<br></code></pre></td></tr></table></figure><h2 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h2><p>HttpServletResponse主要功能用于服务器对客户端的请求进行响应，将web服务器处理后的结果返回给客户端。</p><h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>响应时需要获取输出流，有两种形式（两种不能同时使用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getWriter()<span class="hljs-comment">//获取字符流（只能响应回字符）</span><br>getOutputStream()<span class="hljs-comment">//获取字节流（能响应一切数据）</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符输出流</span><br>PrintWriter writer=response.getwriter();<br>writer.write(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">//或者 writer.println(&quot;hello&quot;);</span><br>writer.write(<span class="hljs-string">&quot;&lt;h2&gt;hello&lt;/h2&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字节输出流</span><br><span class="hljs-type">ServletOUtputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>out.write(<span class="hljs-string">&quot;Hello&quot;</span>.getBytes());<br>out.write(<span class="hljs-string">&quot;&lt;h2&gt;Hello&lt;/h2&gt;&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><h3 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置服务端的编码格式</span><br>response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//设置客户端的编码格式</span><br>response.setHeader(<span class="hljs-string">&quot;content-type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>)<br></code></pre></td></tr></table></figure><p>设置客户端和服务端的编码格式，且保持一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同时设置客户端和服务端的编码格式</span><br>response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>第二种方法好一点。</p><p>注：编码格式要在所有输出流前面设置，如果设置编码格式前面有一个输出都会导致编码格式设置失效</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>1.是一种服务端指导客户端行为，2.存在两次请求，3.地址栏会改变，4.request对象不共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重定向到index.jsp</span><br>response.sendRedirect(<span class="hljs-string">&quot;index.jsp&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="重定向与请求转发的区别"><a href="#重定向与请求转发的区别" class="headerlink" title="重定向与请求转发的区别"></a>重定向与请求转发的区别</h4><table><thead><tr><th align="left">请求转发 [ request.getRequestDispatcher().forward() ]</th><th>重定向 [ response.sendRedirect() ]</th></tr></thead><tbody><tr><td align="left">一次请求，数据在request域中共享</td><td>两次请求，request域中数据不共享</td></tr><tr><td align="left">服务端行为</td><td>客户端行为</td></tr><tr><td align="left">地址栏不发生改变</td><td>地址栏发生改变</td></tr><tr><td align="left">绝对地址定位到站点后（只能到当前站点下）</td><td>绝对地址可写到http:&#x2F;&#x2F;</td></tr></tbody></table><h2 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h2><p>浏览器的一种技术，通过服务器的程序能将一些只须保存在客户端，或者客户端进行处理的数据，放在本地计算机上，提高网页的处理效率，但由于是服务端保持客户端的信息，所有安全性很差（浏览器记者密码）。</p><h3 id="Cooike的创建和发送"><a href="#Cooike的创建和发送" class="headerlink" title="Cooike的创建和发送"></a>Cooike的创建和发送</h3><p>通过<code>new Cookie(&quot;key&quot;,&quot;value&quot;);</code>来创建对象，要响应发到客户端，需先添加到response对象中，<code>response.addCookie(cookie);</code>此时cookie对象则随着响应发送至客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建Cookie对象</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;uame&quot;</span>,<span class="hljs-string">&quot;lingqu&quot;</span>);<br><span class="hljs-comment">//发送Cookie对象</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><h3 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h3><p>用<code>getCookie()</code>方法获取返回的是cookie数组，获取单个需要遍历，<code>getName()</code>获取Cookie的名称，<code>getValue()</code>获取Cookie的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Cookie数组</span><br>Cookie[] cookies = request.getCookies();<br><span class="hljs-comment">//判断数组是否为空</span><br><span class="hljs-keyword">if</span>(cookies != <span class="hljs-literal">null</span> &amp;&amp; cookies.length &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//遍历数组</span><br>    <span class="hljs-keyword">for</span>(Cookie cookie : cookies)&#123;<br>        System.out.println(cookie.getName());<br>        System.out.println(cookie.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Cookie设置到期时间"><a href="#Cookie设置到期时间" class="headerlink" title="Cookie设置到期时间"></a>Cookie设置到期时间</h3><p>我们可以手动设定cookie的有效时间，通过<code>setMaxAge(int time);</code>方法设定cookie的最大有效时间，单位(秒).</p><h4 id="到期时间的取值"><a href="#到期时间的取值" class="headerlink" title="到期时间的取值"></a>到期时间的取值</h4><ul><li><p>负整数</p><p>表示不储存cookie。maxAge的默认值就是-1，表示只在浏览器内存中存活，关闭浏览器，cookie会消失</p></li><li><p>正整数</p><p>表示cookie可储存的秒数。大于0时，会把cookie保存到硬盘上，关闭浏览器，重启客户端电脑，cookie也存活相应的时间</p></li><li><p>零</p><p>表示删除该cookie。无论在浏览器内存中还是客户端硬盘上都会删除这个cookie。</p></li></ul><h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>​ <code>setPath</code>设置cookie路径，路径直接决定服务器的请求是否会从浏览器中加载某些cookie。</p><ul><li><p>服务器任何项目的任意资源都可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前项目路径为：s01</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">//设置路径为&quot;/&quot;,表示在当前服务器下任何项目都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure></li><li><p>当前项目下的资源可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前项目路径为：s01</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">//设置路径为&quot;/s01&quot;,表示在当前项目下任何项目都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01&quot;</span>);<span class="hljs-comment">//默认情况，可不设置path的值</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure></li><li><p>指定项目下的资源可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前项目路径为：s01</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">//设置路径为&quot;/s02&quot;,表示在s02项目下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s02&quot;</span>);<span class="hljs-comment">//只能在s02项目下获取Cookie，就算cookie是s01产生的，s01也不能获取它</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure></li><li><p>指定目录下的资源可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前项目路径为：s01</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-comment">//设置路径为&quot;/s01/cook&quot;,表示在s01/cook目录下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01/cook&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure></li></ul><p>注：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含cookie路径，则该请求不会携带该cookie。</p><h2 id="HttpSession对象"><a href="#HttpSession对象" class="headerlink" title="HttpSession对象"></a>HttpSession对象</h2><p>每个客户端都是一个session。Session的作用就是为了标记一次会话，或者确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过<code>request.getSession()</code>方法，来获取当前会话session对象。</p><p>当获取session对象时，会先判断session对象是否存在，如果存在，则获取session对象；如果不存在，就创建session对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-comment">//获取session会话标识符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> session.getId();<br>System.out.println(id);<br><span class="hljs-comment">//获取session的创建时间</span><br>System.out.println(session.getCreationTime());<br><span class="hljs-comment">//获取最后一次访问时间</span><br>System.out.println(session.getLastAccessedTime());<br><span class="hljs-comment">//判断是否是新的session对象</span><br>System.out.println(session.isNew());<br></code></pre></td></tr></table></figure><h3 id="标识符JSESSIONID"><a href="#标识符JSESSIONID" class="headerlink" title="标识符JSESSIONID"></a>标识符JSESSIONID</h3><p>​每当一次请求到达服务器，如果开启了会话(访问了session)，服务器第一步会查看是否从客户端回传一个名为JSESSIONID的cookie，如果没有则认为这是一次新的会话，会创建一个新的session对象，并用唯一的sessionld为此次会话做一个标志。如果有JESSIONID这个cookie回传，服务器则会根据JSESSIONID这个值去查看是否含有id为]SESSION值的session对象，如果没有则认为是一个新的会话，重新创建一个新的session对象，并标志此次会话;如果找到了相应的session对象，则认为是之前标志过的一次会话，返回该session对象，数据达到共享。<br>​这里提到一个叫做JSESSIONID的cookie，这是一个比较特殊的cookie，当用户请求服务器时，如果访问了sessionI则服务器会创建一个名为JSESSIONID，值为获取到的session (无论是获取到的还是新创建的)的sessionld的cookie对象，并添加到 response对象中，响应给客户端，有效时间为关闭浏览器。<br>​所以Session的底层依赖Cookie来实现。</p><h3 id="session域对象"><a href="#session域对象" class="headerlink" title="session域对象"></a>session域对象</h3><p>Session用来表示一次会话，在一次会话中数据是可以共享的，这时session作为域对象存在，可以通过<code>setAttribute(name,value)</code>方法向域对象中添加数据，通过<code>getAttribute(name)</code>从域对象中获取数据，通过<code>removeAttribute(name)</code>从域对象中移除数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><br><span class="hljs-comment">//设置session域对象</span><br>session.setAttribute(<span class="hljs-string">&quot;uname&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>session.setAttribute(<span class="hljs-string">&quot;upwd&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><br><span class="hljs-comment">//移除session对象</span><br>session.removeAttribute(<span class="hljs-string">&quot;upwd&quot;</span>);<br><br><span class="hljs-comment">//request对象</span><br>request.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br><br><span class="hljs-comment">//请求转发到jsp页面(Session对象和request对象都可以传值)</span><br><span class="hljs-comment">//req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);</span><br><span class="hljs-comment">//重定向到jsp页面(Session可以传值)</span><br>response.sendRedirect(<span class="hljs-string">&quot;index.jsp&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Session对象的销毁"><a href="#Session对象的销毁" class="headerlink" title="Session对象的销毁"></a>Session对象的销毁</h3><ul><li><p>默认时间到期</p><p>tomcat中session默认存活时间为30min，即你不操作界面的时间，一旦有操作，session会重新计时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认的最大不活动时间，单位（分钟）</span><br>&lt;session-config&gt;<br>    &lt;session-timeout&gt;<span class="hljs-number">30</span>&lt;/session-timeout&gt;<br>&lt;/session-config&gt;<br></code></pre></td></tr></table></figure></li><li><p>自己设定到期时间</p><p>通过<code>session.setMaxInactiveInterval(int)</code>来设置session的最大不活动时间，单位（秒）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-comment">//获取最大不活动时间</span><br>session.getMaxInactiveInterval();<br><span class="hljs-comment">//设置session的最大不活动时间</span><br>session.setMaxInactiveInterval(<span class="hljs-number">15</span>);  <span class="hljs-comment">//15秒</span><br></code></pre></td></tr></table></figure></li><li><p>立即销毁</p><p>可以通过<code>session.invalidate()</code>方法让session立刻失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//销毁session对象</span><br>session.invalidate();<br></code></pre></td></tr></table></figure></li><li><p>关闭浏览器</p><p>从前面的JESSIONID可知道,session的底层依赖cookie实现，并且该cookie的有效时间为关闭浏览器，从而session在浏览器关闭时也相当于失效了(因为没有JSESSION再与之对应)。</p></li><li><p>关闭服务器</p><p>当关闭服务器时，session 销毁。Session失效则意味着此次会话结束，数据共享结束。</p></li></ul><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p>每一个web应用都有且仅有一个ServletContext对象，又称Application对象，从名称中可知，该对象是与应用程序相关的。在WEB容器启动的时候，会为每一个WEB应用程序创建一个对应的ServletContext对象。</p><p>该对象有两大作用，第一、作为域对象用来共享数据，此时数据在整个应用程序中共享;第二、该对象中保存了当前应用程序相关信息。例如可以通过<code>getServerInfo()</code>方法获取当前服务器信息，<code>getRealPath(Stringpath)</code>获取资源的真实路径等。</p><h3 id="ServletContext对象的获取"><a href="#ServletContext对象的获取" class="headerlink" title="ServletContext对象的获取"></a>ServletContext对象的获取</h3><p> 获取ServletContext对象的途径有很多。比如:</p><ul><li><p>通过request对象获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext() ;<br></code></pre></td></tr></table></figure></li><li><p>通过session对象获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getSession(). getservletContext();<br></code></pre></td></tr></table></figure></li><li><p>通过servletConfig 对象获取在Servlet标准中提供了ServletConfig 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext3</span> <span class="hljs-operator">=</span> getServletConfig().getServletContext();<br></code></pre></td></tr></table></figure></li><li><p>直接获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext4</span> <span class="hljs-operator">=</span> getServletContext();<br></code></pre></td></tr></table></figure></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、获取当前服务器的版本信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">servletInfo</span> <span class="hljs-operator">=</span> request.getServletContext().getServerInfo();<br>System.out.println(<span class="hljs-string">&quot;当前服务器的版本信息: &quot;</span>+ servletInfo);<br><span class="hljs-comment">//获取项目真实路径</span><br><span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;项目真实路径: &quot;</span>+realPath);<br></code></pre></td></tr></table></figure></li></ul><h3 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h3><p>ServletContext 也可当做域对象来使用，通过向ServletContext 中存取数据，可以使得整个应用程序共享某些数据。当然不建议存放过多数据，因为ServletContext 中的数据一旦存储进去没有手动移除将会一直保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取servletcontext对象</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br><br><span class="hljs-comment">//设置域对象</span><br>servletContext.setAttribute(<span class="hljs-string">&quot;name&quot;</span> , <span class="hljs-string">&quot;zhangsan&quot;</span>) ;<br>/获取域对象<br><span class="hljs-type">String</span> <span class="hljs-variable">uname</span> <span class="hljs-operator">=</span> (String) servletContext.getAttribute(<span class="hljs-string">&quot;name&quot;</span>) ;<br><span class="hljs-comment">//移除域对象</span><br>servletContext.removeAttribute(<span class="hljs-string">&quot;uname&quot;</span>) ;<br></code></pre></td></tr></table></figure><h4 id="Servlet的三大域对象"><a href="#Servlet的三大域对象" class="headerlink" title="Servlet的三大域对象"></a>Servlet的三大域对象</h4><h5 id="request域对象"><a href="#request域对象" class="headerlink" title="request域对象"></a>request域对象</h5><p>在一次请求中有效。请求转发有效，重定向失效。</p><h5 id="session域对象-1"><a href="#session域对象-1" class="headerlink" title="session域对象"></a>session域对象</h5><p>在一次会话中有效。请求转发和重定向都有效，session销毁后失效。</p><h5 id="servletContext域对象"><a href="#servletContext域对象" class="headerlink" title="servletContext域对象"></a>servletContext域对象</h5><p>在整个应用程序中有效。服务器关闭后失效。</p><h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="前台页面"><a href="#前台页面" class="headerlink" title="前台页面"></a>前台页面</h4><p>在做文件上传的时候，会有一个上传文件的界面，首先我们需要一个表单，并且表单的请求方式为POST;其次我们的form表单的enctype必须设为”multipart&#x2F;form-data”，即<code>enctype=&quot;multipart/form-data&quot;</code>，意思是设置表单的类型为文件上传表单。默认情况下这个表单类型是<code>&quot;application/x-www-form-urlencoded&quot;</code>,不能用于文件上传。只有使用了<code>multipart/form-data </code>才能完整地传递文件数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">文件上传表单</span><br><span class="hljs-comment">1．表单提交类型method=&quot;post&quot;</span><br><span class="hljs-comment">2．表单类型enctype=&quot;multipart/form-data&quot;</span><br><span class="hljs-comment">3．表单元素类型文件域设置name属性值</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;uploadServlet&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    姓名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;uname&quot;</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    文件: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myfile&quot;</span> &gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="后台设置"><a href="#后台设置" class="headerlink" title="后台设置"></a>后台设置</h4><p>使用注解<code>@MultipartConfig</code>将一个Servlet标识为支持文件上传。Servlet将 <code>multipart/form-data</code>的POST请求封装成Part，通过Part对上传的文件进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Context;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.MultipartConfig;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.Part;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-meta">@WebServlet(&quot;/uploadServlet&quot;)</span><br><span class="hljs-meta">@MultipartConfig</span>   <span class="hljs-comment">//如果是文件上次必须加</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件上传...&quot;</span>);<br>        <span class="hljs-comment">//设置请求编码</span><br>        request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">//获取普通参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;uname&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;uname: &quot;</span>+name);<br><br>        <span class="hljs-comment">//获取part文件</span><br>        <span class="hljs-type">Part</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> request.getPart(<span class="hljs-string">&quot;myfile&quot;</span>);<span class="hljs-comment">//表单中文件的属性值</span><br>        <span class="hljs-comment">//通过part对象得到文件上传名</span><br>        String filename=part.getSubmittedFileName();<br>        System.out.println(<span class="hljs-string">&quot;filename&quot;</span>+filename);<br>        <span class="hljs-comment">//得到文件存放的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;文件存放的路径：&quot;</span>+ filePath);<br>        <span class="hljs-comment">//上次文件到指定目录</span><br>        part.write(filePath+<span class="hljs-string">&quot;/&quot;</span>+filename);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><h4 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h4><p>当我们在HTML或JSP页面中使用a标签时，原意是希望能够进行跳转，但当超链接遇到浏览器不识别的资源时会自动下载;当遇见浏览器能够直接显示的资源，浏览器就会默认显示出来，比如txt、png、jpg等。当然我们也可以通过download 属性规定浏览器进行下载。但有些浏览器并不支持。</p><ul><li><p>默认下载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--当超链接遇到浏览器不识别的资源时，会自动下载--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;test.zip&quot;</span>&gt;</span>超链接下载&lt;/ a&gt;<br></code></pre></td></tr></table></figure></li><li><p>指定download 属性下载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--当超链接遇到浏览器识别的资源时，默认不会下载。通过download属性可进行下载--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;test.txt&quot;</span> <span class="hljs-attr">down1oad</span>&gt;</span>超链接下载&lt;/ a&gt;<br></code></pre></td></tr></table></figure><p>download属性可以不写任何信息，会自动使用默认文件名。如果设置了download属性的值，则使用设置的值做为文件名。当用户打开浏览器点击链接的时候就会直接下载文件。</p></li></ul><h4 id="后台实现下载"><a href="#后台实现下载" class="headerlink" title="后台实现下载"></a>后台实现下载</h4><ul><li>实现步骤<ol><li>需要通过<code>response.setContentType</code>方法设置<code>Content-type</code>头字段的值，为浏览器无法使用某种方式或激活某个程序来处理的MIME类型，例如<code>&quot;application/octet-stream&quot;</code>或<code>&quot;application/x-msdownload&quot;</code>等。</li><li>需要通过<code>response.setHeader</code>方法设置<code>Content-Disposition</code>头的值为<code>&quot;attachmentfilename=文件名&quot;</code></li><li>读取下载文件，调用<code>response.getOutputStream</code>方法向客户端写入附件内容。</li></ol></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;downdload&quot;</span> &gt;</span><br>    文件名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fileName&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入文件信息&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在web文件夹里新建了个download文件夹，将可下载的文件放在download文件夹里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Context;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-meta">@WebServlet(&quot;/downdload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">donmlode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-comment">//获取参数（文件名）</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;fileName&quot;</span>);<br>        <span class="hljs-comment">//非空判断  trim():去除字符前后的空格</span><br>        <span class="hljs-keyword">if</span>(fileName == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(fileName.trim()))&#123;<br>            response.getWriter().write(<span class="hljs-string">&quot;请输入要下载的文件名&quot;</span>);<br>            response.getWriter().close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取图片存放的位置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span>request.getServletContext().getRealPath(<span class="hljs-string">&quot;/download/&quot;</span>);<br>        <span class="hljs-comment">//通过路径得到一个file对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+fileName);<br>        <span class="hljs-comment">//判断文件是否存在并且是个标准文件</span><br>        <span class="hljs-keyword">if</span>(file.exists()&amp;&amp;file.isFile())&#123;<br>            <span class="hljs-comment">//设置响应类型（浏览器无法使用某种方式或激活某个程序来处理的 MIME类型</span><br>            response.setContentType(<span class="hljs-string">&quot;application/x-msdownload&quot;</span>);<br>            <span class="hljs-comment">//设置响应头</span><br>            response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>,<span class="hljs-string">&quot;attachment;filename=&quot;</span> + fileName);<br>            <span class="hljs-comment">//得到file文件输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>            <span class="hljs-comment">//得到字节输出流</span><br>            <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span>response.getOutputStream();<br>            <span class="hljs-comment">//定义byte数组</span><br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-comment">//定义数组</span><br>            <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//循环输出</span><br>            <span class="hljs-keyword">while</span>((len = in.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//输出</span><br>                out.write(bytes,<span class="hljs-number">0</span>,len);<br>            &#125;<br>            <span class="hljs-comment">//关闭资源</span><br>            out.close();<br>            in.close();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            response.getWriter().write(<span class="hljs-string">&quot;文件不存在，请重试&quot;</span>);<br>            response.getWriter().close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：需要下载的文件的文件名不能以数字开头否则找不到文件</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>猜数字游戏</title>
    <link href="/2021/05/27/guessGame/"/>
    <url>/2021/05/27/guessGame/</url>
    
    <content type="html"><![CDATA[<p>开发一个猜数字游戏。游戏应随机选择一个 100 以内的自然数, 然后邀请玩家在 10 轮以内猜出这个数字。每轮后都应告知玩家的答案正确与否，如果出错了，则告诉他数字是低了还是高了。并且应显示出玩家前一轮所猜的数字。一旦玩家猜对，或者用尽所有机会，游戏将结束。游戏结束后，可以让玩家选择再次开始。</p><span id="more"></span><p>用到Math里的方法设置随机数，由于Math.random()在范围从<strong>0到</strong>小于<strong>1</strong>的伪随机数，可以用Math.floor()来取<strong>一个表示小于或等于指定数字的最大整数的数字</strong>，随机数与玩家猜的数比较，并给出提示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建一个100以内的随机数</span><br><span class="hljs-keyword">let</span> randomNumber = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="textContent与-innerText-的区别"><a href="#textContent与-innerText-的区别" class="headerlink" title="textContent与 innerText 的区别"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent#%E4%B8%8E_innertext_%E7%9A%84%E5%8C%BA%E5%88%AB">textContent与 <strong>innerText</strong> 的区别</a></h3><p>与 <code>Node.textContent</code>  名字看起来很相似，但有重要的不同之处：</p><ul><li><code>textContent</code> 会获取<em>所有</em>元素的内容，包括 <code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素，然而 <code>innerText</code> 只展示给人看的元素。</li><li><code>textContent</code>会返回节点中的每一个元素。相反，<code>innerText</code>受 CSS 样式的影响，并且不会返回隐藏元素的文本，</li><li>此外，由于 <code>innerText</code> 受 CSS 样式的影响，它会触发回流（ <a href="https://wiki.developer.mozilla.org/en-US/docs/Glossary/Reflow">reflow</a> ）去确保是最新的计算样式。（回流在计算上可能会非常昂贵，因此应尽可能避免。）</li><li>与 <code>textContent</code> 不同的是, 在 Internet Explorer (小于和等于 11 的版本) 中对 <code>innerText</code> 进行修改， 不仅会移除当前元素的子节点，而且还会<em>永久性地破坏</em>所有后代文本节点。在之后不可能再次将节点再次插入到任何其他元素或同一元素中。</li></ul><p>在学着做这个游戏中学到如何用 js 动态创建元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建新元素</span><br>resetButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>    resetButton.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;开始新游戏&quot;</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(resetButton);<br><span class="hljs-comment">//删除新元素</span><br>resetButton.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(resetButton);<br></code></pre></td></tr></table></figure><ol><li>随机生成一个 100 以内的自然数。</li><li>记录玩家当前的轮数。从 1 开始。</li><li>为玩家提供一种猜测数字的方法。</li><li>一旦有结果提交，先将其记录下来，以便用户可以看到他们先前的猜测。</li><li>然后检查它是否正确。</li><li>如果正确：<ol><li>显示祝贺消息。</li><li>阻止玩家继续猜测（这会使游戏混乱）。</li><li>显示控件允许玩家重新开始游戏。</li></ol></li><li>如果出错，并且玩家有剩余轮次：<ol><li>告诉玩家他们错了。</li><li>允许他们输入另一个猜测。</li><li>轮数加 1。</li></ol></li><li>如果出错，并且玩家没有剩余轮次：<ol><li>告诉玩家游戏结束。</li><li>阻止玩家继续猜测（这会使游戏混乱）。</li><li>显示控件允许玩家重新开始游戏。</li></ol></li><li>一旦游戏重启，确保游戏的逻辑和UI完全重置，然后返回步骤1。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.guessResult</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>猜数字游戏<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里将会设一个1~100的数字，你有10次机会去猜出它，我会给你提示猜大还是猜小了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>请输入<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;guessField&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;guessSubmit&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lastGuesses&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;guessResult&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hint&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> guessField = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.guessField&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> guessSubmit = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.guessSubmit&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> lastGuesses = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.lastGuesses&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> guessResult = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.guessResult&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> hint = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.hint&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> randomNumber = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> guessCount = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> resetButton;</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkGuess</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> userGuess = <span class="hljs-title class_">Number</span>(guessField.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (guessCount == <span class="hljs-number">1</span>) &#123;</span><br><span class="language-javascript">      lastGuesses.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;上次输入&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    lastGuesses.<span class="hljs-property">textContent</span> += userGuess + <span class="hljs-string">&quot; &quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (randomNumber == userGuess) &#123;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;你猜对了 !&quot;</span>;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;green&quot;</span>;</span><br><span class="language-javascript">      hint.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-title function_">setGameOver</span>();</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (guessCount == <span class="hljs-number">10</span>) &#123;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;！！！游戏结束！！！&quot;</span>;</span><br><span class="language-javascript">      <span class="hljs-title function_">setGameOver</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (randomNumber &gt; userGuess) &#123;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;你猜错了 !&quot;</span>;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;</span><br><span class="language-javascript">      hint.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;你猜小了&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (randomNumber &lt; userGuess) &#123;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;你猜错了 !&quot;</span>;</span><br><span class="language-javascript">      guessResult.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;red&quot;</span>;</span><br><span class="language-javascript">      hint.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;你猜大了&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    guessCount++;</span><br><span class="language-javascript">    guessField.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="language-javascript">    guessField.<span class="hljs-title function_">focus</span>();</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  guessSubmit.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, checkGuess);</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setGameOver</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    guessField.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">    guessSubmit.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    resetButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);</span><br><span class="language-javascript">    resetButton.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;开始新游戏&quot;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(resetButton);</span><br><span class="language-javascript">    resetButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, resetGame);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetGame</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    guessField.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    guessSubmit.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">    randomNumber = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);</span><br><span class="language-javascript">    guessCount = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.result p&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">      p[i].<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    resetButton.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(resetButton);</span><br><span class="language-javascript">    guessField.<span class="hljs-title function_">focus</span>();</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94queue/"/>
    <url>/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94queue/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>具有一定操作约束的线性表。</p><p>只能在一端插入，而在另一端删除。</p><p>数据插入：入队</p><p>数据删除：出队</p><p>（先来先出）</p><span id="more"></span><p>循环队列：</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-16_18-03-52.png" alt="art"></p><h2 id="顺序存储（数组）"><a href="#顺序存储（数组）" class="headerlink" title="顺序存储（数组）"></a>顺序存储（数组）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize <span class="hljs-string">&lt;最大个数&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span>&#123;<br>ElementType Data[MaxSize];    <br>    <span class="hljs-type">int</span> rear;<br>    <span class="hljs-type">int</span> front;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddQ</span><span class="hljs-params">(QNode* PtrQ,ElementType item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//求余是判断是否满了，满了从头开始（循环队列）</span><br>    <span class="hljs-keyword">if</span>((PtrQ-&gt;rear+<span class="hljs-number">1</span>)%MaxSize == PtrQ-&gt;front)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列满&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="hljs-number">1</span>)%MaxSize;<br>    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">(QNode* PtrQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(PtrQ-&gt;rear==PtrQ-&gt;front)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列空&quot;</span>;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PtrQ-&gt;front=(PtrQ-&gt;front+<span class="hljs-number">1</span>)%MaxSiz;<br>        <span class="hljs-keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>链表头做删除操作（front）</p><p>链表尾做插入操作（rear）</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-16_18-13-59.png" alt="art"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    ElementType Data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *Next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *rear;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *front;<br>&#125;;<br>QNode *PtrQ;<br></code></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddQ</span><span class="hljs-params">(ElementType X,QNode *PtrQ)</span></span>&#123;<br>    NOde *Cell;<br>    Cell=(QNode*)<span class="hljs-keyword">new</span> QNode;<br>    Cell-&gt;Data=X;<br>    Cell-&gt;Next=<span class="hljs-literal">NULL</span>;<br>    PtrQ-&gt;rear=Cell;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ElementType <span class="hljs-title">Delete</span><span class="hljs-params">(QNode* PtrQ)</span></span>&#123;<br>    Node* Cell;<br>    ElementType FrontElem;<br>    <span class="hljs-keyword">if</span>(PtrQ-&gt;front==<span class="hljs-literal">NULL</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;链表为空&quot;</span>;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    Cell=PtrQ-&gt;front;<br>    FrontElem=PtrQ-&gt;front-&gt;Data;<br>    <span class="hljs-keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)&#123;<br>        <span class="hljs-comment">//说明只有一个元素删了后链表为空</span><br>        PtrQ-&gt;front=PtrQ-&gt;rear=<span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> Cell;<br>    <span class="hljs-keyword">return</span> FrontElem;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆栈</title>
    <link href="/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Stack/"/>
    <url>/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Stack/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>插入数据：入栈（Push）</p></li><li><p>删除数据：出栈（Pop）</p></li><li><p>后入先出：Last In First Out（LIFO）</p><span id="more"></span></li></ul><p><img src="http://images.changzer.cn/Snipaste_2021-05-15_20-59-10.png" alt="art"></p><h2 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h2><p>储存结构通常由一个一维数组和一个记录栈顶元素位置的变量组成</p><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize <span class="hljs-string">&lt;最大元素个数&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SNode</span>&#123;<br>   ElementType Data[MaxSize];  <br>    <span class="hljs-type">int</span> Top;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(SNode* PtrTop,Element item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(PtrTop-&gt;Top==MaxSize<span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;堆栈满&quot;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        PtrTop-&gt;Data[++(PtrTop-&gt;Top)]=item;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">(SNode* PtrTop)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(PtrTop=<span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈为空&quot;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">return</span> (PtrTop-&gt;Data[PtrTop-&gt;Top--]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现堆栈"><a href="#链表实现堆栈" class="headerlink" title="链表实现堆栈"></a>链表实现堆栈</h2><p>栈的链式存储结构实际上是一个单链表，叫做链栈。</p><p>Top在链表头上。</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-15_21-25-59.png" alt="art"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SNode</span><br>&#123;<br>ElementType Data;<br>    SNode* next;<br>&#125;;<br><span class="hljs-comment">//构建一个堆栈的头结点，返回指针</span><br><span class="hljs-function">SNode* <span class="hljs-title">CreateStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SNode *PtrTop;<br>    PtrTop=(SNode*)<span class="hljs-keyword">new</span> SNode;<br>    PtrTop-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> PtrTop;<br>&#125;<br><span class="hljs-comment">//判断堆栈是否为空</span><br><span class="hljs-function">SNode* <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SNode PtrTop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (PtrTop-&gt;next == <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(ElementType item,SNode* PtrTop)</span></span><br><span class="hljs-function"></span>&#123;<br>    SNode* p;<br>    p=(SNode*)<span class="hljs-keyword">new</span> SNode;<br>    p-&gt;next=PtrTop-&gt;next;<br>    p-&gt;Data=item;<br>    PtrTop-&gt;next=p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ElemtType <span class="hljs-title">Pop</span><span class="hljs-params">(SNode* PtrTop)</span></span><br><span class="hljs-function"></span>&#123;<br>    SNode* FirstCell;<br>    ElementType TopElem;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsEmpty</span>(PtrTop))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;堆栈为空&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        FirstCell=PtrTop-&gt;Next;<br>        PtrTop-&gt;next=FirstCell-&gt;next;<br>        TopElem = FirstCell-&gt;Data;<br>        <span class="hljs-keyword">delete</span> FirstCell;<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94linearList/"/>
    <url>/2021/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94linearList/</url>
    
    <content type="html"><![CDATA[<p>线性表：由同类型数据元素构成有序序列的线性结构</p><ul><li>表中元素个数称为线性表的长度</li><li>没有元素时，称为空表</li><li>起始位置称表头，表结束位置称表尾<span id="more"></span></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>利用数组的连续空间顺序存放线性表的各元素</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-15_15-38-27.png" alt="art"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *List;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;<br>ElementType Data[MAXSIZE];<br>    <span class="hljs-type">int</span> Last;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> L;<br>List PtrL;<br><span class="hljs-comment">//访问数据：L.Data[i]或PtrL-&gt;Data[i]</span><br><span class="hljs-comment">//线性表的长度：L.Last+1或PtrL-&gt;Last+1</span><br></code></pre></td></tr></table></figure><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>（建立空的顺序表）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">List <span class="hljs-title">MakeEmpty</span><span class="hljs-params">()</span></span>&#123;<br>List PtrL;<br>PtrL = (List) <span class="hljs-keyword">new</span> LNode;<br>    PtrL-&gt;Last=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> PtrL;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X,LIst PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;Ptrl-&gt;Last &amp;&amp; PtrL-&gt;data[i]!=X)<br>        i++;<br>    <span class="hljs-keyword">if</span>(i&gt;PtrL-&gt;Last)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>(第i(1&lt;&#x3D;i&lt;&#x3D;n+1)个位置上插入一个值为X新元素)</p><p>因为下标是从0开始，所以实际上需要把i-1及以后的所以元素都向后移动一位再在i-1位置放入新元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(ElementType X,<span class="hljs-type">int</span> i,List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//判断表是否满和插入的位置是否合法</span><br>    <span class="hljs-keyword">if</span>(PtrL-&gt;Last==MAXSIZE)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;表满&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i &gt; PtrL-&gt;Last+<span class="hljs-number">2</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;位置不合法&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//移动i-1及以后的元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=PtrL-&gt;Last;j&gt;=i<span class="hljs-number">-1</span>;j--)&#123;<br>        PtrL-&gt;Data[j+<span class="hljs-number">1</span>]=PtrL-&gt;Data[j];<br>    &#125;<br>    PtrL-&gt;Data[i<span class="hljs-number">-1</span>]=X;<span class="hljs-comment">//插入数据</span><br>    PtrL-&gt;Last++;<span class="hljs-comment">//Last仍指向最后一个位置</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>（删除第i（1&lt;&#x3D;i&lt;&#x3D;n）位置的元素）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span> <span class="hljs-params">(<span class="hljs-type">int</span> i,List PtrL)</span></span>&#123;<br>    <span class="hljs-comment">//判断i是否合法</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i &gt; PtrL-&gt;Last+<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;不存在第&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;个元素&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//把i-1位置后面的元素向前挪</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;PtrL-&gt;Last;j++)&#123;<br>        PtrL-&gt;Data[j<span class="hljs-number">-1</span>]=PtrL-&gt;Data[j];<br>    &#125;<br>    PtrL-&gt;Last--;<span class="hljs-comment">//Last仍指向最后</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>我们需要先创建一个结构体（里面包含一个数据、一个后继指针）</p><p>data 用来储存数据，</p><p>next 后继指针用来储存下一节点的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>   <span class="hljs-type">int</span> data;<br>    node* next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们再创建几个结构体指针 node *head， *p， *q， *t。</p><p>head指针：用来储存链表的首地址。</p><p>p指针：为临时指针，来储存新建的节点</p><p>q指针：储存上一节点的地址</p><p>t指针：用来遍历节点</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-14_20-41-25.png" alt="art"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> data;<br>node* next;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><br>node* p, * q, * t, * head;<br>head = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//初始化头指针为空</span><br>q = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> n, a;<br>cout &lt;&lt; <span class="hljs-string">&quot;输入数据个数&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; a;<br>p = (node*)<span class="hljs-keyword">new</span> node;<span class="hljs-comment">//申请一个空间,用来存放一个节点，并临时指针p指向该节点</span><br>p-&gt;data = a;<span class="hljs-comment">//储存数据在data里</span><br>p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设置当前节点的后继指针指向空，即为链尾</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) head = p; <span class="hljs-comment">//如果头指针为空，则头指针指向p</span><br><span class="hljs-keyword">else</span> q-&gt; next=p ;<span class="hljs-comment">//如果不是第一个节点，则把上一节点的后继指针指向临时指针</span><br>q = p;<br>&#125;<br>t = head;<br><span class="hljs-keyword">while</span> (t != <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; t-&gt;data &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要操作-1"><a href="#主要操作-1" class="headerlink" title="主要操作"></a>主要操作</h3><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><p>进行一次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(node* PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    node8 p=PtrL; <span class="hljs-comment">//p指向头指针</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-number">0</span>)&#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>（1）按序号查找</p><p>输入第k位置，返回k位置的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">node* <span class="hljs-title">FindKth</span><span class="hljs-params">(<span class="hljs-type">int</span> k,node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    node* p=head;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; i&lt;k)<br>    &#123;<br>        p=p-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i==k) <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到第k个，返回指针</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//没找到</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(2)按值查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">node *<span class="hljs-title">Find</span><span class="hljs-params">(ElementType X,node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    node* p=head;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;Data!=x)<br>        p=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(p-&gt;Data==x) <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//找到</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//没找到</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>插入数据就是让前一个数据的后继指针指向新的节点，新的节点的后继指针指向后一个节点。</p><p><img src="http://images.changzer.cn/Snipaste_2021-05-14_22-52-16.png" alt="art"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入在第i-1（1&lt;=i&lt;=n+1)个节点后插入一个值为X的新节点</span><br><br><span class="hljs-function">node *<span class="hljs-title">INsert</span><span class="hljs-params">(ElementType X,<span class="hljs-type">int</span> i,node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    node* p,* s;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//插入点在表头</span><br>        s=(node*)<span class="hljs-keyword">new</span> node;<br>        s-&gt;next=head;<br>        s-&gt;Data=X;<br>        <span class="hljs-keyword">return</span> s; <span class="hljs-comment">//返回新表头指针</span><br>    &#125;<br>    p = <span class="hljs-built_in">FindKth</span>(i<span class="hljs-number">-1</span>,head);<span class="hljs-comment">//查找第i-1节点</span><br>    <span class="hljs-keyword">if</span>(p = <span class="hljs-literal">NULL</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;参数错误&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        s=(node*)<span class="hljs-keyword">new</span> node;<span class="hljs-comment">//申请新节点</span><br>        s-&gt;next=p-&gt;next;<span class="hljs-comment">//临时指针后继指针指向现在节点的下一个节点</span><br>        s-&gt;data=X;<br>        p-&gt;next=s;<span class="hljs-comment">//当前节点的后继指针指向临时节点</span><br>        <span class="hljs-keyword">return</span> head;<span class="hljs-comment">//返回头指针</span><br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>(1)找到i-1节点，p指向</p><p>(2)指针s指向要被删除的结点，p的下一结点</p><p>(3)修改指针，删除s所指向结点</p><p>(4)最后释放s所指结点的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">node* <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">int</span> i,node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    node* p,* s;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        s=head;<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)<br>            head = head-&gt;next;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">delete</span> s;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    p = <span class="hljs-built_in">FinKth</span>(i<span class="hljs-number">-1</span>,head);<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt;i<span class="hljs-number">-1</span> &lt;&lt;<span class="hljs-string">&quot;结点不存在&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>)<br>        cout&lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;结点不存在&quot;</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        s=p-&gt;next;<br>        p-&gt;next=s-&gt;next;<br>        <span class="hljs-keyword">delete</span> s;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>全部代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> Data;<br>node* next;<br>&#125;;<br><span class="hljs-comment">//查找函数</span><br><span class="hljs-function">node* <span class="hljs-title">FindKth</span><span class="hljs-params">(<span class="hljs-type">int</span> k, node* head)</span> </span>&#123;<br>node* p = head;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; i &lt; k) &#123;<br>p = p-&gt;next;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span> (i == k) <span class="hljs-keyword">return</span> p;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-function">node* <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">int</span> i, node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>node* p, *s;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>s = head;<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">NULL</span>) head = head-&gt;next;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">delete</span> s;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>p=<span class="hljs-built_in">FindKth</span>(i - <span class="hljs-number">1</span>, head);<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个元素不存在&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个元素不存在&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>s = p-&gt;next;<br>p-&gt;next = s-&gt;next;<br><span class="hljs-keyword">delete</span> s;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//插入</span><br><span class="hljs-function">node* <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> X,<span class="hljs-type">int</span> i, node* head)</span></span><br><span class="hljs-function"></span>&#123;<br>node* p,* q;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>p = (node*)<span class="hljs-keyword">new</span> node;<br>p-&gt;Data = X;<br>p-&gt;next = head;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>q = <span class="hljs-built_in">FindKth</span>(i - <span class="hljs-number">1</span>, head);<br><span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;参数错误&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>p = (node*)<span class="hljs-keyword">new</span> node;<br>p-&gt;Data = X;<br>p-&gt;next = q-&gt;next;<br>q-&gt;next = p;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>node* head, * p, * q, * t;<br>head = <span class="hljs-literal">NULL</span>;<br>q = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> n, a;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; a;<br>p = (node*)<span class="hljs-keyword">new</span> node;<br>p-&gt;Data = a;<br>p-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>head = p;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>q-&gt;next = p;<br>&#125;<br>q = p;<br>&#125;<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">100</span>, <span class="hljs-number">3</span>, head);<br>t = head;<br><span class="hljs-built_in">Delete</span>(<span class="hljs-number">2</span>, head);<br><span class="hljs-keyword">while</span> (t != <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; t-&gt;Data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>t = t-&gt;next;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h4><p>多重链表：链表中的结点可能同时属于多个链</p><p>多重链表中节点的指针域会有多个（但包含两个指针域的链表并不一定是多重链表，比如双向链表）</p><p>to be continue …</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一次博客</title>
    <link href="/2021/05/14/first/"/>
    <url>/2021/05/14/first/</url>
    
    <content type="html"><![CDATA[<p>经过几天不断的尝试终于是搭起来了！<br>好耶！</p><span id="more"></span><p>我希望能够通过博客记录自己的成长,分享自己的见解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
